{-
   Kubernetes

   No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)

   OpenAPI spec version: 2.0
   Kubernetes API version: v1.9.2
   Generated by Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
-}

{-|
Module : Kubernetes.API.AppsV1beta2
-}

{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE MonoLocalBinds #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing -fno-warn-unused-binds -fno-warn-unused-imports #-}

module Kubernetes.API.AppsV1beta2 where

import Kubernetes.Core
import Kubernetes.MimeTypes
import Kubernetes.Model as M

import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Proxy as P (Proxy(..))
import qualified Data.Set as Set
import qualified Data.String as P
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Text.Lazy as TL
import qualified Data.Text.Lazy.Encoding as TL
import qualified Data.Time as TI
import qualified Network.HTTP.Client.MultipartFormData as NH
import qualified Network.HTTP.Media as ME
import qualified Network.HTTP.Types as NH
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Data.Text (Text)
import GHC.Base ((<|>))

import Prelude ((==),(/=),($), (.),(<$>),(<*>),(>>=),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)
import qualified Prelude as P

-- * Operations


-- ** AppsV1beta2

-- *** createNamespacedControllerRevision

-- | @POST \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/controllerrevisions@
-- 
-- create a ControllerRevision
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createNamespacedControllerRevision 
  :: (Consumes CreateNamespacedControllerRevision contentType, MimeRender contentType V1beta2ControllerRevision)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1beta2ControllerRevision -- ^ "body"
  -> KubernetesRequest CreateNamespacedControllerRevision contentType V1beta2ControllerRevision accept
createNamespacedControllerRevision _  _ (Namespace namespace) body =
  _mkRequest "POST" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/controllerrevisions"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateNamespacedControllerRevision 
instance HasBodyParam CreateNamespacedControllerRevision V1beta2ControllerRevision 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateNamespacedControllerRevision Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance MimeType mtype => Consumes CreateNamespacedControllerRevision mtype

-- | @application/json@
instance Produces CreateNamespacedControllerRevision MimeJSON
-- | @application/yaml@
instance Produces CreateNamespacedControllerRevision MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateNamespacedControllerRevision MimeVndKubernetesProtobuf


-- *** createNamespacedDaemonSet

-- | @POST \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/daemonsets@
-- 
-- create a DaemonSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createNamespacedDaemonSet 
  :: (Consumes CreateNamespacedDaemonSet contentType, MimeRender contentType V1beta2DaemonSet)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1beta2DaemonSet -- ^ "body"
  -> KubernetesRequest CreateNamespacedDaemonSet contentType V1beta2DaemonSet accept
createNamespacedDaemonSet _  _ (Namespace namespace) body =
  _mkRequest "POST" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/daemonsets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateNamespacedDaemonSet 
instance HasBodyParam CreateNamespacedDaemonSet V1beta2DaemonSet 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateNamespacedDaemonSet Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance MimeType mtype => Consumes CreateNamespacedDaemonSet mtype

-- | @application/json@
instance Produces CreateNamespacedDaemonSet MimeJSON
-- | @application/yaml@
instance Produces CreateNamespacedDaemonSet MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateNamespacedDaemonSet MimeVndKubernetesProtobuf


-- *** createNamespacedDeployment

-- | @POST \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/deployments@
-- 
-- create a Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createNamespacedDeployment 
  :: (Consumes CreateNamespacedDeployment contentType, MimeRender contentType V1beta2Deployment)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1beta2Deployment -- ^ "body"
  -> KubernetesRequest CreateNamespacedDeployment contentType V1beta2Deployment accept
createNamespacedDeployment _  _ (Namespace namespace) body =
  _mkRequest "POST" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/deployments"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateNamespacedDeployment 
instance HasBodyParam CreateNamespacedDeployment V1beta2Deployment 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateNamespacedDeployment Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance MimeType mtype => Consumes CreateNamespacedDeployment mtype

-- | @application/json@
instance Produces CreateNamespacedDeployment MimeJSON
-- | @application/yaml@
instance Produces CreateNamespacedDeployment MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateNamespacedDeployment MimeVndKubernetesProtobuf


-- *** createNamespacedReplicaSet

-- | @POST \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/replicasets@
-- 
-- create a ReplicaSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createNamespacedReplicaSet 
  :: (Consumes CreateNamespacedReplicaSet contentType, MimeRender contentType V1beta2ReplicaSet)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1beta2ReplicaSet -- ^ "body"
  -> KubernetesRequest CreateNamespacedReplicaSet contentType V1beta2ReplicaSet accept
createNamespacedReplicaSet _  _ (Namespace namespace) body =
  _mkRequest "POST" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/replicasets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateNamespacedReplicaSet 
instance HasBodyParam CreateNamespacedReplicaSet V1beta2ReplicaSet 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateNamespacedReplicaSet Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance MimeType mtype => Consumes CreateNamespacedReplicaSet mtype

-- | @application/json@
instance Produces CreateNamespacedReplicaSet MimeJSON
-- | @application/yaml@
instance Produces CreateNamespacedReplicaSet MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateNamespacedReplicaSet MimeVndKubernetesProtobuf


-- *** createNamespacedStatefulSet

-- | @POST \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/statefulsets@
-- 
-- create a StatefulSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createNamespacedStatefulSet 
  :: (Consumes CreateNamespacedStatefulSet contentType, MimeRender contentType V1beta2StatefulSet)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1beta2StatefulSet -- ^ "body"
  -> KubernetesRequest CreateNamespacedStatefulSet contentType V1beta2StatefulSet accept
createNamespacedStatefulSet _  _ (Namespace namespace) body =
  _mkRequest "POST" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/statefulsets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateNamespacedStatefulSet 
instance HasBodyParam CreateNamespacedStatefulSet V1beta2StatefulSet 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateNamespacedStatefulSet Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance MimeType mtype => Consumes CreateNamespacedStatefulSet mtype

-- | @application/json@
instance Produces CreateNamespacedStatefulSet MimeJSON
-- | @application/yaml@
instance Produces CreateNamespacedStatefulSet MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateNamespacedStatefulSet MimeVndKubernetesProtobuf


-- *** deleteCollectionNamespacedControllerRevision

-- | @DELETE \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/controllerrevisions@
-- 
-- delete collection of ControllerRevision
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionNamespacedControllerRevision 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest DeleteCollectionNamespacedControllerRevision MimeNoContent V1Status accept
deleteCollectionNamespacedControllerRevision  _ (Namespace namespace) =
  _mkRequest "DELETE" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/controllerrevisions"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionNamespacedControllerRevision  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionNamespacedControllerRevision Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionNamespacedControllerRevision Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedControllerRevision FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam DeleteCollectionNamespacedControllerRevision IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedControllerRevision LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionNamespacedControllerRevision Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionNamespacedControllerRevision ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam DeleteCollectionNamespacedControllerRevision TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam DeleteCollectionNamespacedControllerRevision Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance MimeType mtype => Consumes DeleteCollectionNamespacedControllerRevision mtype

-- | @application/json@
instance Produces DeleteCollectionNamespacedControllerRevision MimeJSON
-- | @application/yaml@
instance Produces DeleteCollectionNamespacedControllerRevision MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionNamespacedControllerRevision MimeVndKubernetesProtobuf


-- *** deleteCollectionNamespacedDaemonSet

-- | @DELETE \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/daemonsets@
-- 
-- delete collection of DaemonSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionNamespacedDaemonSet 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest DeleteCollectionNamespacedDaemonSet MimeNoContent V1Status accept
deleteCollectionNamespacedDaemonSet  _ (Namespace namespace) =
  _mkRequest "DELETE" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/daemonsets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionNamespacedDaemonSet  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionNamespacedDaemonSet Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionNamespacedDaemonSet Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedDaemonSet FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam DeleteCollectionNamespacedDaemonSet IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedDaemonSet LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionNamespacedDaemonSet Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionNamespacedDaemonSet ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam DeleteCollectionNamespacedDaemonSet TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam DeleteCollectionNamespacedDaemonSet Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance MimeType mtype => Consumes DeleteCollectionNamespacedDaemonSet mtype

-- | @application/json@
instance Produces DeleteCollectionNamespacedDaemonSet MimeJSON
-- | @application/yaml@
instance Produces DeleteCollectionNamespacedDaemonSet MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionNamespacedDaemonSet MimeVndKubernetesProtobuf


-- *** deleteCollectionNamespacedDeployment

-- | @DELETE \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/deployments@
-- 
-- delete collection of Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionNamespacedDeployment 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest DeleteCollectionNamespacedDeployment MimeNoContent V1Status accept
deleteCollectionNamespacedDeployment  _ (Namespace namespace) =
  _mkRequest "DELETE" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/deployments"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionNamespacedDeployment  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionNamespacedDeployment Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionNamespacedDeployment Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedDeployment FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam DeleteCollectionNamespacedDeployment IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedDeployment LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionNamespacedDeployment Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionNamespacedDeployment ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam DeleteCollectionNamespacedDeployment TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam DeleteCollectionNamespacedDeployment Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance MimeType mtype => Consumes DeleteCollectionNamespacedDeployment mtype

-- | @application/json@
instance Produces DeleteCollectionNamespacedDeployment MimeJSON
-- | @application/yaml@
instance Produces DeleteCollectionNamespacedDeployment MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionNamespacedDeployment MimeVndKubernetesProtobuf


-- *** deleteCollectionNamespacedReplicaSet

-- | @DELETE \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/replicasets@
-- 
-- delete collection of ReplicaSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionNamespacedReplicaSet 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest DeleteCollectionNamespacedReplicaSet MimeNoContent V1Status accept
deleteCollectionNamespacedReplicaSet  _ (Namespace namespace) =
  _mkRequest "DELETE" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/replicasets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionNamespacedReplicaSet  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionNamespacedReplicaSet Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionNamespacedReplicaSet Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedReplicaSet FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam DeleteCollectionNamespacedReplicaSet IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedReplicaSet LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionNamespacedReplicaSet Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionNamespacedReplicaSet ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam DeleteCollectionNamespacedReplicaSet TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam DeleteCollectionNamespacedReplicaSet Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance MimeType mtype => Consumes DeleteCollectionNamespacedReplicaSet mtype

-- | @application/json@
instance Produces DeleteCollectionNamespacedReplicaSet MimeJSON
-- | @application/yaml@
instance Produces DeleteCollectionNamespacedReplicaSet MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionNamespacedReplicaSet MimeVndKubernetesProtobuf


-- *** deleteCollectionNamespacedStatefulSet

-- | @DELETE \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/statefulsets@
-- 
-- delete collection of StatefulSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionNamespacedStatefulSet 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest DeleteCollectionNamespacedStatefulSet MimeNoContent V1Status accept
deleteCollectionNamespacedStatefulSet  _ (Namespace namespace) =
  _mkRequest "DELETE" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/statefulsets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionNamespacedStatefulSet  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionNamespacedStatefulSet Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionNamespacedStatefulSet Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedStatefulSet FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam DeleteCollectionNamespacedStatefulSet IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedStatefulSet LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionNamespacedStatefulSet Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionNamespacedStatefulSet ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam DeleteCollectionNamespacedStatefulSet TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam DeleteCollectionNamespacedStatefulSet Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance MimeType mtype => Consumes DeleteCollectionNamespacedStatefulSet mtype

-- | @application/json@
instance Produces DeleteCollectionNamespacedStatefulSet MimeJSON
-- | @application/yaml@
instance Produces DeleteCollectionNamespacedStatefulSet MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionNamespacedStatefulSet MimeVndKubernetesProtobuf


-- *** deleteNamespacedControllerRevision

-- | @DELETE \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/controllerrevisions\/{name}@
-- 
-- delete a ControllerRevision
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteNamespacedControllerRevision 
  :: (Consumes DeleteNamespacedControllerRevision contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ControllerRevision
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeleteNamespacedControllerRevision contentType V1Status accept
deleteNamespacedControllerRevision _  _ (Name name) (Namespace namespace) body =
  _mkRequest "DELETE" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/controllerrevisions/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeleteNamespacedControllerRevision 
instance HasBodyParam DeleteNamespacedControllerRevision V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteNamespacedControllerRevision Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteNamespacedControllerRevision GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteNamespacedControllerRevision OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteNamespacedControllerRevision PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance MimeType mtype => Consumes DeleteNamespacedControllerRevision mtype

-- | @application/json@
instance Produces DeleteNamespacedControllerRevision MimeJSON
-- | @application/yaml@
instance Produces DeleteNamespacedControllerRevision MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteNamespacedControllerRevision MimeVndKubernetesProtobuf


-- *** deleteNamespacedDaemonSet

-- | @DELETE \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/daemonsets\/{name}@
-- 
-- delete a DaemonSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteNamespacedDaemonSet 
  :: (Consumes DeleteNamespacedDaemonSet contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the DaemonSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeleteNamespacedDaemonSet contentType V1Status accept
deleteNamespacedDaemonSet _  _ (Name name) (Namespace namespace) body =
  _mkRequest "DELETE" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/daemonsets/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeleteNamespacedDaemonSet 
instance HasBodyParam DeleteNamespacedDaemonSet V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteNamespacedDaemonSet Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteNamespacedDaemonSet GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteNamespacedDaemonSet OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteNamespacedDaemonSet PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance MimeType mtype => Consumes DeleteNamespacedDaemonSet mtype

-- | @application/json@
instance Produces DeleteNamespacedDaemonSet MimeJSON
-- | @application/yaml@
instance Produces DeleteNamespacedDaemonSet MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteNamespacedDaemonSet MimeVndKubernetesProtobuf


-- *** deleteNamespacedDeployment

-- | @DELETE \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/deployments\/{name}@
-- 
-- delete a Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteNamespacedDeployment 
  :: (Consumes DeleteNamespacedDeployment contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Deployment
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeleteNamespacedDeployment contentType V1Status accept
deleteNamespacedDeployment _  _ (Name name) (Namespace namespace) body =
  _mkRequest "DELETE" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/deployments/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeleteNamespacedDeployment 
instance HasBodyParam DeleteNamespacedDeployment V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteNamespacedDeployment Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteNamespacedDeployment GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteNamespacedDeployment OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteNamespacedDeployment PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance MimeType mtype => Consumes DeleteNamespacedDeployment mtype

-- | @application/json@
instance Produces DeleteNamespacedDeployment MimeJSON
-- | @application/yaml@
instance Produces DeleteNamespacedDeployment MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteNamespacedDeployment MimeVndKubernetesProtobuf


-- *** deleteNamespacedReplicaSet

-- | @DELETE \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/replicasets\/{name}@
-- 
-- delete a ReplicaSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteNamespacedReplicaSet 
  :: (Consumes DeleteNamespacedReplicaSet contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ReplicaSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeleteNamespacedReplicaSet contentType V1Status accept
deleteNamespacedReplicaSet _  _ (Name name) (Namespace namespace) body =
  _mkRequest "DELETE" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/replicasets/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeleteNamespacedReplicaSet 
instance HasBodyParam DeleteNamespacedReplicaSet V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteNamespacedReplicaSet Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteNamespacedReplicaSet GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteNamespacedReplicaSet OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteNamespacedReplicaSet PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance MimeType mtype => Consumes DeleteNamespacedReplicaSet mtype

-- | @application/json@
instance Produces DeleteNamespacedReplicaSet MimeJSON
-- | @application/yaml@
instance Produces DeleteNamespacedReplicaSet MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteNamespacedReplicaSet MimeVndKubernetesProtobuf


-- *** deleteNamespacedStatefulSet

-- | @DELETE \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/statefulsets\/{name}@
-- 
-- delete a StatefulSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteNamespacedStatefulSet 
  :: (Consumes DeleteNamespacedStatefulSet contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the StatefulSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeleteNamespacedStatefulSet contentType V1Status accept
deleteNamespacedStatefulSet _  _ (Name name) (Namespace namespace) body =
  _mkRequest "DELETE" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/statefulsets/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeleteNamespacedStatefulSet 
instance HasBodyParam DeleteNamespacedStatefulSet V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteNamespacedStatefulSet Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteNamespacedStatefulSet GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteNamespacedStatefulSet OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteNamespacedStatefulSet PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance MimeType mtype => Consumes DeleteNamespacedStatefulSet mtype

-- | @application/json@
instance Produces DeleteNamespacedStatefulSet MimeJSON
-- | @application/yaml@
instance Produces DeleteNamespacedStatefulSet MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteNamespacedStatefulSet MimeVndKubernetesProtobuf


-- *** getAPIResources

-- | @GET \/apis\/apps\/v1beta2\/@
-- 
-- get available resources
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
getAPIResources 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest GetAPIResources MimeNoContent V1APIResourceList accept
getAPIResources  _ =
  _mkRequest "GET" ["/apis/apps/v1beta2/"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data GetAPIResources  

-- | @application/json@
instance Consumes GetAPIResources MimeJSON
-- | @application/yaml@
instance Consumes GetAPIResources MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Consumes GetAPIResources MimeVndKubernetesProtobuf

-- | @application/json@
instance Produces GetAPIResources MimeJSON
-- | @application/yaml@
instance Produces GetAPIResources MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces GetAPIResources MimeVndKubernetesProtobuf


-- *** listControllerRevisionForAllNamespaces

-- | @GET \/apis\/apps\/v1beta2\/controllerrevisions@
-- 
-- list or watch objects of kind ControllerRevision
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listControllerRevisionForAllNamespaces 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListControllerRevisionForAllNamespaces MimeNoContent V1beta2ControllerRevisionList accept
listControllerRevisionForAllNamespaces  _ =
  _mkRequest "GET" ["/apis/apps/v1beta2/controllerrevisions"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListControllerRevisionForAllNamespaces  

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListControllerRevisionForAllNamespaces Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListControllerRevisionForAllNamespaces FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListControllerRevisionForAllNamespaces IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListControllerRevisionForAllNamespaces LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListControllerRevisionForAllNamespaces Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListControllerRevisionForAllNamespaces Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListControllerRevisionForAllNamespaces ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListControllerRevisionForAllNamespaces TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListControllerRevisionForAllNamespaces Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance MimeType mtype => Consumes ListControllerRevisionForAllNamespaces mtype

-- | @application/json@
instance Produces ListControllerRevisionForAllNamespaces MimeJSON
-- | @application/yaml@
instance Produces ListControllerRevisionForAllNamespaces MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListControllerRevisionForAllNamespaces MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListControllerRevisionForAllNamespaces MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListControllerRevisionForAllNamespaces MimeVndKubernetesProtobufstreamwatch


-- *** listDaemonSetForAllNamespaces

-- | @GET \/apis\/apps\/v1beta2\/daemonsets@
-- 
-- list or watch objects of kind DaemonSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listDaemonSetForAllNamespaces 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListDaemonSetForAllNamespaces MimeNoContent V1beta2DaemonSetList accept
listDaemonSetForAllNamespaces  _ =
  _mkRequest "GET" ["/apis/apps/v1beta2/daemonsets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListDaemonSetForAllNamespaces  

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListDaemonSetForAllNamespaces Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListDaemonSetForAllNamespaces FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListDaemonSetForAllNamespaces IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListDaemonSetForAllNamespaces LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListDaemonSetForAllNamespaces Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListDaemonSetForAllNamespaces Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListDaemonSetForAllNamespaces ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListDaemonSetForAllNamespaces TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListDaemonSetForAllNamespaces Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance MimeType mtype => Consumes ListDaemonSetForAllNamespaces mtype

-- | @application/json@
instance Produces ListDaemonSetForAllNamespaces MimeJSON
-- | @application/yaml@
instance Produces ListDaemonSetForAllNamespaces MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListDaemonSetForAllNamespaces MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListDaemonSetForAllNamespaces MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListDaemonSetForAllNamespaces MimeVndKubernetesProtobufstreamwatch


-- *** listDeploymentForAllNamespaces

-- | @GET \/apis\/apps\/v1beta2\/deployments@
-- 
-- list or watch objects of kind Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listDeploymentForAllNamespaces 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListDeploymentForAllNamespaces MimeNoContent V1beta2DeploymentList accept
listDeploymentForAllNamespaces  _ =
  _mkRequest "GET" ["/apis/apps/v1beta2/deployments"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListDeploymentForAllNamespaces  

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListDeploymentForAllNamespaces Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListDeploymentForAllNamespaces FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListDeploymentForAllNamespaces IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListDeploymentForAllNamespaces LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListDeploymentForAllNamespaces Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListDeploymentForAllNamespaces Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListDeploymentForAllNamespaces ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListDeploymentForAllNamespaces TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListDeploymentForAllNamespaces Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance MimeType mtype => Consumes ListDeploymentForAllNamespaces mtype

-- | @application/json@
instance Produces ListDeploymentForAllNamespaces MimeJSON
-- | @application/yaml@
instance Produces ListDeploymentForAllNamespaces MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListDeploymentForAllNamespaces MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListDeploymentForAllNamespaces MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListDeploymentForAllNamespaces MimeVndKubernetesProtobufstreamwatch


-- *** listNamespacedControllerRevision

-- | @GET \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/controllerrevisions@
-- 
-- list or watch objects of kind ControllerRevision
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listNamespacedControllerRevision 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ListNamespacedControllerRevision MimeNoContent V1beta2ControllerRevisionList accept
listNamespacedControllerRevision  _ (Namespace namespace) =
  _mkRequest "GET" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/controllerrevisions"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListNamespacedControllerRevision  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListNamespacedControllerRevision Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListNamespacedControllerRevision Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListNamespacedControllerRevision FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListNamespacedControllerRevision IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListNamespacedControllerRevision LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListNamespacedControllerRevision Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListNamespacedControllerRevision ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListNamespacedControllerRevision TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListNamespacedControllerRevision Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance MimeType mtype => Consumes ListNamespacedControllerRevision mtype

-- | @application/json@
instance Produces ListNamespacedControllerRevision MimeJSON
-- | @application/yaml@
instance Produces ListNamespacedControllerRevision MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListNamespacedControllerRevision MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListNamespacedControllerRevision MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListNamespacedControllerRevision MimeVndKubernetesProtobufstreamwatch


-- *** listNamespacedDaemonSet

-- | @GET \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/daemonsets@
-- 
-- list or watch objects of kind DaemonSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listNamespacedDaemonSet 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ListNamespacedDaemonSet MimeNoContent V1beta2DaemonSetList accept
listNamespacedDaemonSet  _ (Namespace namespace) =
  _mkRequest "GET" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/daemonsets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListNamespacedDaemonSet  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListNamespacedDaemonSet Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListNamespacedDaemonSet Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListNamespacedDaemonSet FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListNamespacedDaemonSet IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListNamespacedDaemonSet LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListNamespacedDaemonSet Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListNamespacedDaemonSet ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListNamespacedDaemonSet TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListNamespacedDaemonSet Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance MimeType mtype => Consumes ListNamespacedDaemonSet mtype

-- | @application/json@
instance Produces ListNamespacedDaemonSet MimeJSON
-- | @application/yaml@
instance Produces ListNamespacedDaemonSet MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListNamespacedDaemonSet MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListNamespacedDaemonSet MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListNamespacedDaemonSet MimeVndKubernetesProtobufstreamwatch


-- *** listNamespacedDeployment

-- | @GET \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/deployments@
-- 
-- list or watch objects of kind Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listNamespacedDeployment 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ListNamespacedDeployment MimeNoContent V1beta2DeploymentList accept
listNamespacedDeployment  _ (Namespace namespace) =
  _mkRequest "GET" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/deployments"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListNamespacedDeployment  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListNamespacedDeployment Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListNamespacedDeployment Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListNamespacedDeployment FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListNamespacedDeployment IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListNamespacedDeployment LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListNamespacedDeployment Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListNamespacedDeployment ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListNamespacedDeployment TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListNamespacedDeployment Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance MimeType mtype => Consumes ListNamespacedDeployment mtype

-- | @application/json@
instance Produces ListNamespacedDeployment MimeJSON
-- | @application/yaml@
instance Produces ListNamespacedDeployment MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListNamespacedDeployment MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListNamespacedDeployment MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListNamespacedDeployment MimeVndKubernetesProtobufstreamwatch


-- *** listNamespacedReplicaSet

-- | @GET \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/replicasets@
-- 
-- list or watch objects of kind ReplicaSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listNamespacedReplicaSet 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ListNamespacedReplicaSet MimeNoContent V1beta2ReplicaSetList accept
listNamespacedReplicaSet  _ (Namespace namespace) =
  _mkRequest "GET" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/replicasets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListNamespacedReplicaSet  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListNamespacedReplicaSet Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListNamespacedReplicaSet Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListNamespacedReplicaSet FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListNamespacedReplicaSet IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListNamespacedReplicaSet LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListNamespacedReplicaSet Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListNamespacedReplicaSet ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListNamespacedReplicaSet TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListNamespacedReplicaSet Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance MimeType mtype => Consumes ListNamespacedReplicaSet mtype

-- | @application/json@
instance Produces ListNamespacedReplicaSet MimeJSON
-- | @application/yaml@
instance Produces ListNamespacedReplicaSet MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListNamespacedReplicaSet MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListNamespacedReplicaSet MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListNamespacedReplicaSet MimeVndKubernetesProtobufstreamwatch


-- *** listNamespacedStatefulSet

-- | @GET \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/statefulsets@
-- 
-- list or watch objects of kind StatefulSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listNamespacedStatefulSet 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ListNamespacedStatefulSet MimeNoContent V1beta2StatefulSetList accept
listNamespacedStatefulSet  _ (Namespace namespace) =
  _mkRequest "GET" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/statefulsets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListNamespacedStatefulSet  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListNamespacedStatefulSet Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListNamespacedStatefulSet Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListNamespacedStatefulSet FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListNamespacedStatefulSet IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListNamespacedStatefulSet LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListNamespacedStatefulSet Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListNamespacedStatefulSet ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListNamespacedStatefulSet TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListNamespacedStatefulSet Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance MimeType mtype => Consumes ListNamespacedStatefulSet mtype

-- | @application/json@
instance Produces ListNamespacedStatefulSet MimeJSON
-- | @application/yaml@
instance Produces ListNamespacedStatefulSet MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListNamespacedStatefulSet MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListNamespacedStatefulSet MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListNamespacedStatefulSet MimeVndKubernetesProtobufstreamwatch


-- *** listReplicaSetForAllNamespaces

-- | @GET \/apis\/apps\/v1beta2\/replicasets@
-- 
-- list or watch objects of kind ReplicaSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listReplicaSetForAllNamespaces 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListReplicaSetForAllNamespaces MimeNoContent V1beta2ReplicaSetList accept
listReplicaSetForAllNamespaces  _ =
  _mkRequest "GET" ["/apis/apps/v1beta2/replicasets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListReplicaSetForAllNamespaces  

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListReplicaSetForAllNamespaces Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListReplicaSetForAllNamespaces FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListReplicaSetForAllNamespaces IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListReplicaSetForAllNamespaces LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListReplicaSetForAllNamespaces Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListReplicaSetForAllNamespaces Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListReplicaSetForAllNamespaces ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListReplicaSetForAllNamespaces TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListReplicaSetForAllNamespaces Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance MimeType mtype => Consumes ListReplicaSetForAllNamespaces mtype

-- | @application/json@
instance Produces ListReplicaSetForAllNamespaces MimeJSON
-- | @application/yaml@
instance Produces ListReplicaSetForAllNamespaces MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListReplicaSetForAllNamespaces MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListReplicaSetForAllNamespaces MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListReplicaSetForAllNamespaces MimeVndKubernetesProtobufstreamwatch


-- *** listStatefulSetForAllNamespaces

-- | @GET \/apis\/apps\/v1beta2\/statefulsets@
-- 
-- list or watch objects of kind StatefulSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listStatefulSetForAllNamespaces 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListStatefulSetForAllNamespaces MimeNoContent V1beta2StatefulSetList accept
listStatefulSetForAllNamespaces  _ =
  _mkRequest "GET" ["/apis/apps/v1beta2/statefulsets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListStatefulSetForAllNamespaces  

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListStatefulSetForAllNamespaces Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListStatefulSetForAllNamespaces FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListStatefulSetForAllNamespaces IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListStatefulSetForAllNamespaces LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListStatefulSetForAllNamespaces Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListStatefulSetForAllNamespaces Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListStatefulSetForAllNamespaces ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListStatefulSetForAllNamespaces TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListStatefulSetForAllNamespaces Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance MimeType mtype => Consumes ListStatefulSetForAllNamespaces mtype

-- | @application/json@
instance Produces ListStatefulSetForAllNamespaces MimeJSON
-- | @application/yaml@
instance Produces ListStatefulSetForAllNamespaces MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListStatefulSetForAllNamespaces MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListStatefulSetForAllNamespaces MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListStatefulSetForAllNamespaces MimeVndKubernetesProtobufstreamwatch


-- *** patchNamespacedControllerRevision

-- | @PATCH \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/controllerrevisions\/{name}@
-- 
-- partially update the specified ControllerRevision
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedControllerRevision 
  :: (Consumes PatchNamespacedControllerRevision contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ControllerRevision
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedControllerRevision contentType V1beta2ControllerRevision accept
patchNamespacedControllerRevision _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/controllerrevisions/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedControllerRevision 
instance HasBodyParam PatchNamespacedControllerRevision A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedControllerRevision Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedControllerRevision MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedControllerRevision MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedControllerRevision MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedControllerRevision MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedControllerRevision MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedControllerRevision MimeVndKubernetesProtobuf


-- *** patchNamespacedDaemonSet

-- | @PATCH \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/daemonsets\/{name}@
-- 
-- partially update the specified DaemonSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedDaemonSet 
  :: (Consumes PatchNamespacedDaemonSet contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the DaemonSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedDaemonSet contentType V1beta2DaemonSet accept
patchNamespacedDaemonSet _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/daemonsets/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedDaemonSet 
instance HasBodyParam PatchNamespacedDaemonSet A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedDaemonSet Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedDaemonSet MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedDaemonSet MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedDaemonSet MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedDaemonSet MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedDaemonSet MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedDaemonSet MimeVndKubernetesProtobuf


-- *** patchNamespacedDaemonSetStatus

-- | @PATCH \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/daemonsets\/{name}\/status@
-- 
-- partially update status of the specified DaemonSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedDaemonSetStatus 
  :: (Consumes PatchNamespacedDaemonSetStatus contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the DaemonSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedDaemonSetStatus contentType V1beta2DaemonSet accept
patchNamespacedDaemonSetStatus _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/daemonsets/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedDaemonSetStatus 
instance HasBodyParam PatchNamespacedDaemonSetStatus A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedDaemonSetStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedDaemonSetStatus MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedDaemonSetStatus MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedDaemonSetStatus MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedDaemonSetStatus MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedDaemonSetStatus MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedDaemonSetStatus MimeVndKubernetesProtobuf


-- *** patchNamespacedDeployment

-- | @PATCH \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/deployments\/{name}@
-- 
-- partially update the specified Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedDeployment 
  :: (Consumes PatchNamespacedDeployment contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Deployment
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedDeployment contentType V1beta2Deployment accept
patchNamespacedDeployment _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/deployments/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedDeployment 
instance HasBodyParam PatchNamespacedDeployment A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedDeployment Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedDeployment MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedDeployment MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedDeployment MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedDeployment MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedDeployment MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedDeployment MimeVndKubernetesProtobuf


-- *** patchNamespacedDeploymentScale

-- | @PATCH \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/deployments\/{name}\/scale@
-- 
-- partially update scale of the specified Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedDeploymentScale 
  :: (Consumes PatchNamespacedDeploymentScale contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Scale
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedDeploymentScale contentType V1beta2Scale accept
patchNamespacedDeploymentScale _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/deployments/",toPath name,"/scale"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedDeploymentScale 
instance HasBodyParam PatchNamespacedDeploymentScale A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedDeploymentScale Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedDeploymentScale MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedDeploymentScale MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedDeploymentScale MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedDeploymentScale MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedDeploymentScale MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedDeploymentScale MimeVndKubernetesProtobuf


-- *** patchNamespacedDeploymentStatus

-- | @PATCH \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/deployments\/{name}\/status@
-- 
-- partially update status of the specified Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedDeploymentStatus 
  :: (Consumes PatchNamespacedDeploymentStatus contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Deployment
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedDeploymentStatus contentType V1beta2Deployment accept
patchNamespacedDeploymentStatus _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/deployments/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedDeploymentStatus 
instance HasBodyParam PatchNamespacedDeploymentStatus A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedDeploymentStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedDeploymentStatus MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedDeploymentStatus MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedDeploymentStatus MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedDeploymentStatus MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedDeploymentStatus MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedDeploymentStatus MimeVndKubernetesProtobuf


-- *** patchNamespacedReplicaSet

-- | @PATCH \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/replicasets\/{name}@
-- 
-- partially update the specified ReplicaSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedReplicaSet 
  :: (Consumes PatchNamespacedReplicaSet contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ReplicaSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedReplicaSet contentType V1beta2ReplicaSet accept
patchNamespacedReplicaSet _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/replicasets/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedReplicaSet 
instance HasBodyParam PatchNamespacedReplicaSet A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedReplicaSet Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedReplicaSet MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedReplicaSet MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedReplicaSet MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedReplicaSet MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedReplicaSet MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedReplicaSet MimeVndKubernetesProtobuf


-- *** patchNamespacedReplicaSetScale

-- | @PATCH \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/replicasets\/{name}\/scale@
-- 
-- partially update scale of the specified ReplicaSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedReplicaSetScale 
  :: (Consumes PatchNamespacedReplicaSetScale contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Scale
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedReplicaSetScale contentType V1beta2Scale accept
patchNamespacedReplicaSetScale _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/replicasets/",toPath name,"/scale"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedReplicaSetScale 
instance HasBodyParam PatchNamespacedReplicaSetScale A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedReplicaSetScale Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedReplicaSetScale MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedReplicaSetScale MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedReplicaSetScale MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedReplicaSetScale MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedReplicaSetScale MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedReplicaSetScale MimeVndKubernetesProtobuf


-- *** patchNamespacedReplicaSetStatus

-- | @PATCH \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/replicasets\/{name}\/status@
-- 
-- partially update status of the specified ReplicaSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedReplicaSetStatus 
  :: (Consumes PatchNamespacedReplicaSetStatus contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ReplicaSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedReplicaSetStatus contentType V1beta2ReplicaSet accept
patchNamespacedReplicaSetStatus _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/replicasets/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedReplicaSetStatus 
instance HasBodyParam PatchNamespacedReplicaSetStatus A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedReplicaSetStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedReplicaSetStatus MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedReplicaSetStatus MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedReplicaSetStatus MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedReplicaSetStatus MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedReplicaSetStatus MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedReplicaSetStatus MimeVndKubernetesProtobuf


-- *** patchNamespacedStatefulSet

-- | @PATCH \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/statefulsets\/{name}@
-- 
-- partially update the specified StatefulSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedStatefulSet 
  :: (Consumes PatchNamespacedStatefulSet contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the StatefulSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedStatefulSet contentType V1beta2StatefulSet accept
patchNamespacedStatefulSet _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/statefulsets/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedStatefulSet 
instance HasBodyParam PatchNamespacedStatefulSet A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedStatefulSet Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedStatefulSet MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedStatefulSet MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedStatefulSet MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedStatefulSet MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedStatefulSet MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedStatefulSet MimeVndKubernetesProtobuf


-- *** patchNamespacedStatefulSetScale

-- | @PATCH \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/statefulsets\/{name}\/scale@
-- 
-- partially update scale of the specified StatefulSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedStatefulSetScale 
  :: (Consumes PatchNamespacedStatefulSetScale contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Scale
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedStatefulSetScale contentType V1beta2Scale accept
patchNamespacedStatefulSetScale _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/statefulsets/",toPath name,"/scale"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedStatefulSetScale 
instance HasBodyParam PatchNamespacedStatefulSetScale A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedStatefulSetScale Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedStatefulSetScale MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedStatefulSetScale MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedStatefulSetScale MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedStatefulSetScale MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedStatefulSetScale MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedStatefulSetScale MimeVndKubernetesProtobuf


-- *** patchNamespacedStatefulSetStatus

-- | @PATCH \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/statefulsets\/{name}\/status@
-- 
-- partially update status of the specified StatefulSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedStatefulSetStatus 
  :: (Consumes PatchNamespacedStatefulSetStatus contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the StatefulSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedStatefulSetStatus contentType V1beta2StatefulSet accept
patchNamespacedStatefulSetStatus _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/statefulsets/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedStatefulSetStatus 
instance HasBodyParam PatchNamespacedStatefulSetStatus A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedStatefulSetStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedStatefulSetStatus MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedStatefulSetStatus MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedStatefulSetStatus MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedStatefulSetStatus MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedStatefulSetStatus MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedStatefulSetStatus MimeVndKubernetesProtobuf


-- *** readNamespacedControllerRevision

-- | @GET \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/controllerrevisions\/{name}@
-- 
-- read the specified ControllerRevision
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedControllerRevision 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ControllerRevision
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedControllerRevision MimeNoContent V1beta2ControllerRevision accept
readNamespacedControllerRevision  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/controllerrevisions/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedControllerRevision  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedControllerRevision Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "exact" - Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.
instance HasOptionalParam ReadNamespacedControllerRevision Exact where
  applyOptionalParam req (Exact xs) =
    req `setQuery` toQuery ("exact", Just xs)

-- | /Optional Param/ "export" - Should this value be exported.  Export strips fields that a user can not specify.
instance HasOptionalParam ReadNamespacedControllerRevision Export where
  applyOptionalParam req (Export xs) =
    req `setQuery` toQuery ("export", Just xs)

-- | @*/*@
instance MimeType mtype => Consumes ReadNamespacedControllerRevision mtype

-- | @application/json@
instance Produces ReadNamespacedControllerRevision MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedControllerRevision MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedControllerRevision MimeVndKubernetesProtobuf


-- *** readNamespacedDaemonSet

-- | @GET \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/daemonsets\/{name}@
-- 
-- read the specified DaemonSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedDaemonSet 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the DaemonSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedDaemonSet MimeNoContent V1beta2DaemonSet accept
readNamespacedDaemonSet  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/daemonsets/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedDaemonSet  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedDaemonSet Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "exact" - Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.
instance HasOptionalParam ReadNamespacedDaemonSet Exact where
  applyOptionalParam req (Exact xs) =
    req `setQuery` toQuery ("exact", Just xs)

-- | /Optional Param/ "export" - Should this value be exported.  Export strips fields that a user can not specify.
instance HasOptionalParam ReadNamespacedDaemonSet Export where
  applyOptionalParam req (Export xs) =
    req `setQuery` toQuery ("export", Just xs)

-- | @*/*@
instance MimeType mtype => Consumes ReadNamespacedDaemonSet mtype

-- | @application/json@
instance Produces ReadNamespacedDaemonSet MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedDaemonSet MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedDaemonSet MimeVndKubernetesProtobuf


-- *** readNamespacedDaemonSetStatus

-- | @GET \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/daemonsets\/{name}\/status@
-- 
-- read status of the specified DaemonSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedDaemonSetStatus 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the DaemonSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedDaemonSetStatus MimeNoContent V1beta2DaemonSet accept
readNamespacedDaemonSetStatus  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/daemonsets/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedDaemonSetStatus  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedDaemonSetStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance MimeType mtype => Consumes ReadNamespacedDaemonSetStatus mtype

-- | @application/json@
instance Produces ReadNamespacedDaemonSetStatus MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedDaemonSetStatus MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedDaemonSetStatus MimeVndKubernetesProtobuf


-- *** readNamespacedDeployment

-- | @GET \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/deployments\/{name}@
-- 
-- read the specified Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedDeployment 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Deployment
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedDeployment MimeNoContent V1beta2Deployment accept
readNamespacedDeployment  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/deployments/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedDeployment  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedDeployment Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "exact" - Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.
instance HasOptionalParam ReadNamespacedDeployment Exact where
  applyOptionalParam req (Exact xs) =
    req `setQuery` toQuery ("exact", Just xs)

-- | /Optional Param/ "export" - Should this value be exported.  Export strips fields that a user can not specify.
instance HasOptionalParam ReadNamespacedDeployment Export where
  applyOptionalParam req (Export xs) =
    req `setQuery` toQuery ("export", Just xs)

-- | @*/*@
instance MimeType mtype => Consumes ReadNamespacedDeployment mtype

-- | @application/json@
instance Produces ReadNamespacedDeployment MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedDeployment MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedDeployment MimeVndKubernetesProtobuf


-- *** readNamespacedDeploymentScale

-- | @GET \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/deployments\/{name}\/scale@
-- 
-- read scale of the specified Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedDeploymentScale 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Scale
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedDeploymentScale MimeNoContent V1beta2Scale accept
readNamespacedDeploymentScale  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/deployments/",toPath name,"/scale"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedDeploymentScale  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedDeploymentScale Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance MimeType mtype => Consumes ReadNamespacedDeploymentScale mtype

-- | @application/json@
instance Produces ReadNamespacedDeploymentScale MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedDeploymentScale MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedDeploymentScale MimeVndKubernetesProtobuf


-- *** readNamespacedDeploymentStatus

-- | @GET \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/deployments\/{name}\/status@
-- 
-- read status of the specified Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedDeploymentStatus 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Deployment
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedDeploymentStatus MimeNoContent V1beta2Deployment accept
readNamespacedDeploymentStatus  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/deployments/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedDeploymentStatus  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedDeploymentStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance MimeType mtype => Consumes ReadNamespacedDeploymentStatus mtype

-- | @application/json@
instance Produces ReadNamespacedDeploymentStatus MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedDeploymentStatus MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedDeploymentStatus MimeVndKubernetesProtobuf


-- *** readNamespacedReplicaSet

-- | @GET \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/replicasets\/{name}@
-- 
-- read the specified ReplicaSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedReplicaSet 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ReplicaSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedReplicaSet MimeNoContent V1beta2ReplicaSet accept
readNamespacedReplicaSet  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/replicasets/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedReplicaSet  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedReplicaSet Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "exact" - Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.
instance HasOptionalParam ReadNamespacedReplicaSet Exact where
  applyOptionalParam req (Exact xs) =
    req `setQuery` toQuery ("exact", Just xs)

-- | /Optional Param/ "export" - Should this value be exported.  Export strips fields that a user can not specify.
instance HasOptionalParam ReadNamespacedReplicaSet Export where
  applyOptionalParam req (Export xs) =
    req `setQuery` toQuery ("export", Just xs)

-- | @*/*@
instance MimeType mtype => Consumes ReadNamespacedReplicaSet mtype

-- | @application/json@
instance Produces ReadNamespacedReplicaSet MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedReplicaSet MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedReplicaSet MimeVndKubernetesProtobuf


-- *** readNamespacedReplicaSetScale

-- | @GET \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/replicasets\/{name}\/scale@
-- 
-- read scale of the specified ReplicaSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedReplicaSetScale 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Scale
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedReplicaSetScale MimeNoContent V1beta2Scale accept
readNamespacedReplicaSetScale  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/replicasets/",toPath name,"/scale"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedReplicaSetScale  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedReplicaSetScale Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance MimeType mtype => Consumes ReadNamespacedReplicaSetScale mtype

-- | @application/json@
instance Produces ReadNamespacedReplicaSetScale MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedReplicaSetScale MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedReplicaSetScale MimeVndKubernetesProtobuf


-- *** readNamespacedReplicaSetStatus

-- | @GET \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/replicasets\/{name}\/status@
-- 
-- read status of the specified ReplicaSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedReplicaSetStatus 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ReplicaSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedReplicaSetStatus MimeNoContent V1beta2ReplicaSet accept
readNamespacedReplicaSetStatus  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/replicasets/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedReplicaSetStatus  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedReplicaSetStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance MimeType mtype => Consumes ReadNamespacedReplicaSetStatus mtype

-- | @application/json@
instance Produces ReadNamespacedReplicaSetStatus MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedReplicaSetStatus MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedReplicaSetStatus MimeVndKubernetesProtobuf


-- *** readNamespacedStatefulSet

-- | @GET \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/statefulsets\/{name}@
-- 
-- read the specified StatefulSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedStatefulSet 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the StatefulSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedStatefulSet MimeNoContent V1beta2StatefulSet accept
readNamespacedStatefulSet  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/statefulsets/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedStatefulSet  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedStatefulSet Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "exact" - Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.
instance HasOptionalParam ReadNamespacedStatefulSet Exact where
  applyOptionalParam req (Exact xs) =
    req `setQuery` toQuery ("exact", Just xs)

-- | /Optional Param/ "export" - Should this value be exported.  Export strips fields that a user can not specify.
instance HasOptionalParam ReadNamespacedStatefulSet Export where
  applyOptionalParam req (Export xs) =
    req `setQuery` toQuery ("export", Just xs)

-- | @*/*@
instance MimeType mtype => Consumes ReadNamespacedStatefulSet mtype

-- | @application/json@
instance Produces ReadNamespacedStatefulSet MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedStatefulSet MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedStatefulSet MimeVndKubernetesProtobuf


-- *** readNamespacedStatefulSetScale

-- | @GET \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/statefulsets\/{name}\/scale@
-- 
-- read scale of the specified StatefulSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedStatefulSetScale 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Scale
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedStatefulSetScale MimeNoContent V1beta2Scale accept
readNamespacedStatefulSetScale  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/statefulsets/",toPath name,"/scale"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedStatefulSetScale  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedStatefulSetScale Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance MimeType mtype => Consumes ReadNamespacedStatefulSetScale mtype

-- | @application/json@
instance Produces ReadNamespacedStatefulSetScale MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedStatefulSetScale MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedStatefulSetScale MimeVndKubernetesProtobuf


-- *** readNamespacedStatefulSetStatus

-- | @GET \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/statefulsets\/{name}\/status@
-- 
-- read status of the specified StatefulSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedStatefulSetStatus 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the StatefulSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedStatefulSetStatus MimeNoContent V1beta2StatefulSet accept
readNamespacedStatefulSetStatus  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/statefulsets/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedStatefulSetStatus  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedStatefulSetStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance MimeType mtype => Consumes ReadNamespacedStatefulSetStatus mtype

-- | @application/json@
instance Produces ReadNamespacedStatefulSetStatus MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedStatefulSetStatus MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedStatefulSetStatus MimeVndKubernetesProtobuf


-- *** replaceNamespacedControllerRevision

-- | @PUT \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/controllerrevisions\/{name}@
-- 
-- replace the specified ControllerRevision
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedControllerRevision 
  :: (Consumes ReplaceNamespacedControllerRevision contentType, MimeRender contentType V1beta2ControllerRevision)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ControllerRevision
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1beta2ControllerRevision -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedControllerRevision contentType V1beta2ControllerRevision accept
replaceNamespacedControllerRevision _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/controllerrevisions/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedControllerRevision 
instance HasBodyParam ReplaceNamespacedControllerRevision V1beta2ControllerRevision 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedControllerRevision Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance MimeType mtype => Consumes ReplaceNamespacedControllerRevision mtype

-- | @application/json@
instance Produces ReplaceNamespacedControllerRevision MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedControllerRevision MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedControllerRevision MimeVndKubernetesProtobuf


-- *** replaceNamespacedDaemonSet

-- | @PUT \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/daemonsets\/{name}@
-- 
-- replace the specified DaemonSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedDaemonSet 
  :: (Consumes ReplaceNamespacedDaemonSet contentType, MimeRender contentType V1beta2DaemonSet)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the DaemonSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1beta2DaemonSet -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedDaemonSet contentType V1beta2DaemonSet accept
replaceNamespacedDaemonSet _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/daemonsets/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedDaemonSet 
instance HasBodyParam ReplaceNamespacedDaemonSet V1beta2DaemonSet 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedDaemonSet Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance MimeType mtype => Consumes ReplaceNamespacedDaemonSet mtype

-- | @application/json@
instance Produces ReplaceNamespacedDaemonSet MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedDaemonSet MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedDaemonSet MimeVndKubernetesProtobuf


-- *** replaceNamespacedDaemonSetStatus

-- | @PUT \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/daemonsets\/{name}\/status@
-- 
-- replace status of the specified DaemonSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedDaemonSetStatus 
  :: (Consumes ReplaceNamespacedDaemonSetStatus contentType, MimeRender contentType V1beta2DaemonSet)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the DaemonSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1beta2DaemonSet -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedDaemonSetStatus contentType V1beta2DaemonSet accept
replaceNamespacedDaemonSetStatus _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/daemonsets/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedDaemonSetStatus 
instance HasBodyParam ReplaceNamespacedDaemonSetStatus V1beta2DaemonSet 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedDaemonSetStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance MimeType mtype => Consumes ReplaceNamespacedDaemonSetStatus mtype

-- | @application/json@
instance Produces ReplaceNamespacedDaemonSetStatus MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedDaemonSetStatus MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedDaemonSetStatus MimeVndKubernetesProtobuf


-- *** replaceNamespacedDeployment

-- | @PUT \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/deployments\/{name}@
-- 
-- replace the specified Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedDeployment 
  :: (Consumes ReplaceNamespacedDeployment contentType, MimeRender contentType V1beta2Deployment)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Deployment
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1beta2Deployment -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedDeployment contentType V1beta2Deployment accept
replaceNamespacedDeployment _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/deployments/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedDeployment 
instance HasBodyParam ReplaceNamespacedDeployment V1beta2Deployment 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedDeployment Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance MimeType mtype => Consumes ReplaceNamespacedDeployment mtype

-- | @application/json@
instance Produces ReplaceNamespacedDeployment MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedDeployment MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedDeployment MimeVndKubernetesProtobuf


-- *** replaceNamespacedDeploymentScale

-- | @PUT \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/deployments\/{name}\/scale@
-- 
-- replace scale of the specified Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedDeploymentScale 
  :: (Consumes ReplaceNamespacedDeploymentScale contentType, MimeRender contentType V1beta2Scale)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Scale
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1beta2Scale -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedDeploymentScale contentType V1beta2Scale accept
replaceNamespacedDeploymentScale _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/deployments/",toPath name,"/scale"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedDeploymentScale 
instance HasBodyParam ReplaceNamespacedDeploymentScale V1beta2Scale 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedDeploymentScale Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance MimeType mtype => Consumes ReplaceNamespacedDeploymentScale mtype

-- | @application/json@
instance Produces ReplaceNamespacedDeploymentScale MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedDeploymentScale MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedDeploymentScale MimeVndKubernetesProtobuf


-- *** replaceNamespacedDeploymentStatus

-- | @PUT \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/deployments\/{name}\/status@
-- 
-- replace status of the specified Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedDeploymentStatus 
  :: (Consumes ReplaceNamespacedDeploymentStatus contentType, MimeRender contentType V1beta2Deployment)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Deployment
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1beta2Deployment -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedDeploymentStatus contentType V1beta2Deployment accept
replaceNamespacedDeploymentStatus _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/deployments/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedDeploymentStatus 
instance HasBodyParam ReplaceNamespacedDeploymentStatus V1beta2Deployment 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedDeploymentStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance MimeType mtype => Consumes ReplaceNamespacedDeploymentStatus mtype

-- | @application/json@
instance Produces ReplaceNamespacedDeploymentStatus MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedDeploymentStatus MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedDeploymentStatus MimeVndKubernetesProtobuf


-- *** replaceNamespacedReplicaSet

-- | @PUT \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/replicasets\/{name}@
-- 
-- replace the specified ReplicaSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedReplicaSet 
  :: (Consumes ReplaceNamespacedReplicaSet contentType, MimeRender contentType V1beta2ReplicaSet)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ReplicaSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1beta2ReplicaSet -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedReplicaSet contentType V1beta2ReplicaSet accept
replaceNamespacedReplicaSet _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/replicasets/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedReplicaSet 
instance HasBodyParam ReplaceNamespacedReplicaSet V1beta2ReplicaSet 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedReplicaSet Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance MimeType mtype => Consumes ReplaceNamespacedReplicaSet mtype

-- | @application/json@
instance Produces ReplaceNamespacedReplicaSet MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedReplicaSet MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedReplicaSet MimeVndKubernetesProtobuf


-- *** replaceNamespacedReplicaSetScale

-- | @PUT \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/replicasets\/{name}\/scale@
-- 
-- replace scale of the specified ReplicaSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedReplicaSetScale 
  :: (Consumes ReplaceNamespacedReplicaSetScale contentType, MimeRender contentType V1beta2Scale)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Scale
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1beta2Scale -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedReplicaSetScale contentType V1beta2Scale accept
replaceNamespacedReplicaSetScale _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/replicasets/",toPath name,"/scale"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedReplicaSetScale 
instance HasBodyParam ReplaceNamespacedReplicaSetScale V1beta2Scale 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedReplicaSetScale Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance MimeType mtype => Consumes ReplaceNamespacedReplicaSetScale mtype

-- | @application/json@
instance Produces ReplaceNamespacedReplicaSetScale MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedReplicaSetScale MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedReplicaSetScale MimeVndKubernetesProtobuf


-- *** replaceNamespacedReplicaSetStatus

-- | @PUT \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/replicasets\/{name}\/status@
-- 
-- replace status of the specified ReplicaSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedReplicaSetStatus 
  :: (Consumes ReplaceNamespacedReplicaSetStatus contentType, MimeRender contentType V1beta2ReplicaSet)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ReplicaSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1beta2ReplicaSet -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedReplicaSetStatus contentType V1beta2ReplicaSet accept
replaceNamespacedReplicaSetStatus _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/replicasets/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedReplicaSetStatus 
instance HasBodyParam ReplaceNamespacedReplicaSetStatus V1beta2ReplicaSet 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedReplicaSetStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance MimeType mtype => Consumes ReplaceNamespacedReplicaSetStatus mtype

-- | @application/json@
instance Produces ReplaceNamespacedReplicaSetStatus MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedReplicaSetStatus MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedReplicaSetStatus MimeVndKubernetesProtobuf


-- *** replaceNamespacedStatefulSet

-- | @PUT \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/statefulsets\/{name}@
-- 
-- replace the specified StatefulSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedStatefulSet 
  :: (Consumes ReplaceNamespacedStatefulSet contentType, MimeRender contentType V1beta2StatefulSet)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the StatefulSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1beta2StatefulSet -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedStatefulSet contentType V1beta2StatefulSet accept
replaceNamespacedStatefulSet _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/statefulsets/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedStatefulSet 
instance HasBodyParam ReplaceNamespacedStatefulSet V1beta2StatefulSet 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedStatefulSet Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance MimeType mtype => Consumes ReplaceNamespacedStatefulSet mtype

-- | @application/json@
instance Produces ReplaceNamespacedStatefulSet MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedStatefulSet MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedStatefulSet MimeVndKubernetesProtobuf


-- *** replaceNamespacedStatefulSetScale

-- | @PUT \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/statefulsets\/{name}\/scale@
-- 
-- replace scale of the specified StatefulSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedStatefulSetScale 
  :: (Consumes ReplaceNamespacedStatefulSetScale contentType, MimeRender contentType V1beta2Scale)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Scale
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1beta2Scale -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedStatefulSetScale contentType V1beta2Scale accept
replaceNamespacedStatefulSetScale _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/statefulsets/",toPath name,"/scale"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedStatefulSetScale 
instance HasBodyParam ReplaceNamespacedStatefulSetScale V1beta2Scale 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedStatefulSetScale Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance MimeType mtype => Consumes ReplaceNamespacedStatefulSetScale mtype

-- | @application/json@
instance Produces ReplaceNamespacedStatefulSetScale MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedStatefulSetScale MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedStatefulSetScale MimeVndKubernetesProtobuf


-- *** replaceNamespacedStatefulSetStatus

-- | @PUT \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/statefulsets\/{name}\/status@
-- 
-- replace status of the specified StatefulSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedStatefulSetStatus 
  :: (Consumes ReplaceNamespacedStatefulSetStatus contentType, MimeRender contentType V1beta2StatefulSet)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the StatefulSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1beta2StatefulSet -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedStatefulSetStatus contentType V1beta2StatefulSet accept
replaceNamespacedStatefulSetStatus _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/statefulsets/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedStatefulSetStatus 
instance HasBodyParam ReplaceNamespacedStatefulSetStatus V1beta2StatefulSet 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedStatefulSetStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance MimeType mtype => Consumes ReplaceNamespacedStatefulSetStatus mtype

-- | @application/json@
instance Produces ReplaceNamespacedStatefulSetStatus MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedStatefulSetStatus MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedStatefulSetStatus MimeVndKubernetesProtobuf

