{-
   Kubernetes

   No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

   OpenAPI Version: 3.0.1
   Kubernetes API version: release-1.16
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : Kubernetes.OpenAPI.API.ExtensionsV1beta1
-}

{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE MonoLocalBinds #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing -fno-warn-unused-binds -fno-warn-unused-imports #-}

module Kubernetes.OpenAPI.API.ExtensionsV1beta1 where

import Kubernetes.OpenAPI.Core
import Kubernetes.OpenAPI.MimeTypes
import Kubernetes.OpenAPI.Model as M

import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Proxy as P (Proxy(..))
import qualified Data.Set as Set
import qualified Data.String as P
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Text.Lazy as TL
import qualified Data.Text.Lazy.Encoding as TL
import qualified Data.Time as TI
import qualified Network.HTTP.Client.MultipartFormData as NH
import qualified Network.HTTP.Media as ME
import qualified Network.HTTP.Types as NH
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Data.Text (Text)
import GHC.Base ((<|>))

import Prelude ((==),(/=),($), (.),(<$>),(<*>),(>>=),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)
import qualified Prelude as P

-- * Operations


-- ** ExtensionsV1beta1

-- *** createNamespacedDaemonSet

-- | @POST \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/daemonsets@
-- 
-- create a DaemonSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createNamespacedDaemonSet 
  :: (Consumes CreateNamespacedDaemonSet contentType, MimeRender contentType V1beta1DaemonSet)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> V1beta1DaemonSet -- ^ "body"
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest CreateNamespacedDaemonSet contentType V1beta1DaemonSet accept
createNamespacedDaemonSet _  _ body (Namespace namespace) =
  _mkRequest "POST" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/daemonsets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateNamespacedDaemonSet 
instance HasBodyParam CreateNamespacedDaemonSet V1beta1DaemonSet 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateNamespacedDaemonSet Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "dryRun" - When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
instance HasOptionalParam CreateNamespacedDaemonSet DryRun where
  applyOptionalParam req (DryRun xs) =
    req `setQuery` toQuery ("dryRun", Just xs)

-- | /Optional Param/ "fieldManager" - fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
instance HasOptionalParam CreateNamespacedDaemonSet FieldManager where
  applyOptionalParam req (FieldManager xs) =
    req `setQuery` toQuery ("fieldManager", Just xs)
    
-- | @*/*@
instance MimeType mtype => Consumes CreateNamespacedDaemonSet mtype

-- | @application/json@
instance Produces CreateNamespacedDaemonSet MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateNamespacedDaemonSet MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces CreateNamespacedDaemonSet MimeYaml


-- *** createNamespacedDeployment

-- | @POST \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/deployments@
-- 
-- create a Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createNamespacedDeployment 
  :: (Consumes CreateNamespacedDeployment contentType, MimeRender contentType ExtensionsV1beta1Deployment)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> ExtensionsV1beta1Deployment -- ^ "body"
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest CreateNamespacedDeployment contentType ExtensionsV1beta1Deployment accept
createNamespacedDeployment _  _ body (Namespace namespace) =
  _mkRequest "POST" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/deployments"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateNamespacedDeployment 
instance HasBodyParam CreateNamespacedDeployment ExtensionsV1beta1Deployment 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateNamespacedDeployment Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "dryRun" - When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
instance HasOptionalParam CreateNamespacedDeployment DryRun where
  applyOptionalParam req (DryRun xs) =
    req `setQuery` toQuery ("dryRun", Just xs)

-- | /Optional Param/ "fieldManager" - fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
instance HasOptionalParam CreateNamespacedDeployment FieldManager where
  applyOptionalParam req (FieldManager xs) =
    req `setQuery` toQuery ("fieldManager", Just xs)
    
-- | @*/*@
instance MimeType mtype => Consumes CreateNamespacedDeployment mtype

-- | @application/json@
instance Produces CreateNamespacedDeployment MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateNamespacedDeployment MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces CreateNamespacedDeployment MimeYaml


-- *** createNamespacedDeploymentRollback

-- | @POST \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/deployments\/{name}\/rollback@
-- 
-- create rollback of a Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createNamespacedDeploymentRollback 
  :: (Consumes CreateNamespacedDeploymentRollback contentType, MimeRender contentType ExtensionsV1beta1DeploymentRollback)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> ExtensionsV1beta1DeploymentRollback -- ^ "body"
  -> Name -- ^ "name" -  name of the DeploymentRollback
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest CreateNamespacedDeploymentRollback contentType V1Status accept
createNamespacedDeploymentRollback _  _ body (Name name) (Namespace namespace) =
  _mkRequest "POST" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/deployments/",toPath name,"/rollback"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateNamespacedDeploymentRollback 
instance HasBodyParam CreateNamespacedDeploymentRollback ExtensionsV1beta1DeploymentRollback 

-- | /Optional Param/ "dryRun" - When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
instance HasOptionalParam CreateNamespacedDeploymentRollback DryRun where
  applyOptionalParam req (DryRun xs) =
    req `setQuery` toQuery ("dryRun", Just xs)

-- | /Optional Param/ "fieldManager" - fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
instance HasOptionalParam CreateNamespacedDeploymentRollback FieldManager where
  applyOptionalParam req (FieldManager xs) =
    req `setQuery` toQuery ("fieldManager", Just xs)

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateNamespacedDeploymentRollback Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)
    
-- | @*/*@
instance MimeType mtype => Consumes CreateNamespacedDeploymentRollback mtype

-- | @application/json@
instance Produces CreateNamespacedDeploymentRollback MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateNamespacedDeploymentRollback MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces CreateNamespacedDeploymentRollback MimeYaml


-- *** createNamespacedIngress

-- | @POST \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/ingresses@
-- 
-- create an Ingress
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createNamespacedIngress 
  :: (Consumes CreateNamespacedIngress contentType, MimeRender contentType ExtensionsV1beta1Ingress)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> ExtensionsV1beta1Ingress -- ^ "body"
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest CreateNamespacedIngress contentType ExtensionsV1beta1Ingress accept
createNamespacedIngress _  _ body (Namespace namespace) =
  _mkRequest "POST" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/ingresses"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateNamespacedIngress 
instance HasBodyParam CreateNamespacedIngress ExtensionsV1beta1Ingress 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateNamespacedIngress Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "dryRun" - When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
instance HasOptionalParam CreateNamespacedIngress DryRun where
  applyOptionalParam req (DryRun xs) =
    req `setQuery` toQuery ("dryRun", Just xs)

-- | /Optional Param/ "fieldManager" - fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
instance HasOptionalParam CreateNamespacedIngress FieldManager where
  applyOptionalParam req (FieldManager xs) =
    req `setQuery` toQuery ("fieldManager", Just xs)
    
-- | @*/*@
instance MimeType mtype => Consumes CreateNamespacedIngress mtype

-- | @application/json@
instance Produces CreateNamespacedIngress MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateNamespacedIngress MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces CreateNamespacedIngress MimeYaml


-- *** createNamespacedNetworkPolicy

-- | @POST \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/networkpolicies@
-- 
-- create a NetworkPolicy
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createNamespacedNetworkPolicy 
  :: (Consumes CreateNamespacedNetworkPolicy contentType, MimeRender contentType V1beta1NetworkPolicy)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> V1beta1NetworkPolicy -- ^ "body"
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest CreateNamespacedNetworkPolicy contentType V1beta1NetworkPolicy accept
createNamespacedNetworkPolicy _  _ body (Namespace namespace) =
  _mkRequest "POST" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/networkpolicies"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateNamespacedNetworkPolicy 
instance HasBodyParam CreateNamespacedNetworkPolicy V1beta1NetworkPolicy 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateNamespacedNetworkPolicy Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "dryRun" - When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
instance HasOptionalParam CreateNamespacedNetworkPolicy DryRun where
  applyOptionalParam req (DryRun xs) =
    req `setQuery` toQuery ("dryRun", Just xs)

-- | /Optional Param/ "fieldManager" - fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
instance HasOptionalParam CreateNamespacedNetworkPolicy FieldManager where
  applyOptionalParam req (FieldManager xs) =
    req `setQuery` toQuery ("fieldManager", Just xs)
    
-- | @*/*@
instance MimeType mtype => Consumes CreateNamespacedNetworkPolicy mtype

-- | @application/json@
instance Produces CreateNamespacedNetworkPolicy MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateNamespacedNetworkPolicy MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces CreateNamespacedNetworkPolicy MimeYaml


-- *** createNamespacedReplicaSet

-- | @POST \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/replicasets@
-- 
-- create a ReplicaSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createNamespacedReplicaSet 
  :: (Consumes CreateNamespacedReplicaSet contentType, MimeRender contentType V1beta1ReplicaSet)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> V1beta1ReplicaSet -- ^ "body"
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest CreateNamespacedReplicaSet contentType V1beta1ReplicaSet accept
createNamespacedReplicaSet _  _ body (Namespace namespace) =
  _mkRequest "POST" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/replicasets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateNamespacedReplicaSet 
instance HasBodyParam CreateNamespacedReplicaSet V1beta1ReplicaSet 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateNamespacedReplicaSet Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "dryRun" - When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
instance HasOptionalParam CreateNamespacedReplicaSet DryRun where
  applyOptionalParam req (DryRun xs) =
    req `setQuery` toQuery ("dryRun", Just xs)

-- | /Optional Param/ "fieldManager" - fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
instance HasOptionalParam CreateNamespacedReplicaSet FieldManager where
  applyOptionalParam req (FieldManager xs) =
    req `setQuery` toQuery ("fieldManager", Just xs)
    
-- | @*/*@
instance MimeType mtype => Consumes CreateNamespacedReplicaSet mtype

-- | @application/json@
instance Produces CreateNamespacedReplicaSet MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateNamespacedReplicaSet MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces CreateNamespacedReplicaSet MimeYaml


-- *** createPodSecurityPolicy

-- | @POST \/apis\/extensions\/v1beta1\/podsecuritypolicies@
-- 
-- create a PodSecurityPolicy
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createPodSecurityPolicy 
  :: (Consumes CreatePodSecurityPolicy contentType, MimeRender contentType ExtensionsV1beta1PodSecurityPolicy)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> ExtensionsV1beta1PodSecurityPolicy -- ^ "body"
  -> KubernetesRequest CreatePodSecurityPolicy contentType ExtensionsV1beta1PodSecurityPolicy accept
createPodSecurityPolicy _  _ body =
  _mkRequest "POST" ["/apis/extensions/v1beta1/podsecuritypolicies"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreatePodSecurityPolicy 
instance HasBodyParam CreatePodSecurityPolicy ExtensionsV1beta1PodSecurityPolicy 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreatePodSecurityPolicy Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "dryRun" - When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
instance HasOptionalParam CreatePodSecurityPolicy DryRun where
  applyOptionalParam req (DryRun xs) =
    req `setQuery` toQuery ("dryRun", Just xs)

-- | /Optional Param/ "fieldManager" - fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
instance HasOptionalParam CreatePodSecurityPolicy FieldManager where
  applyOptionalParam req (FieldManager xs) =
    req `setQuery` toQuery ("fieldManager", Just xs)
    
-- | @*/*@
instance MimeType mtype => Consumes CreatePodSecurityPolicy mtype

-- | @application/json@
instance Produces CreatePodSecurityPolicy MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreatePodSecurityPolicy MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces CreatePodSecurityPolicy MimeYaml


-- *** deleteCollectionNamespacedDaemonSet

-- | @DELETE \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/daemonsets@
-- 
-- delete collection of DaemonSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionNamespacedDaemonSet 
  :: (Consumes DeleteCollectionNamespacedDaemonSet contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest DeleteCollectionNamespacedDaemonSet contentType V1Status accept
deleteCollectionNamespacedDaemonSet _  _ (Namespace namespace) =
  _mkRequest "DELETE" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/daemonsets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionNamespacedDaemonSet 
instance HasBodyParam DeleteCollectionNamespacedDaemonSet V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionNamespacedDaemonSet Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionNamespacedDaemonSet Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "dryRun" - When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
instance HasOptionalParam DeleteCollectionNamespacedDaemonSet DryRun where
  applyOptionalParam req (DryRun xs) =
    req `setQuery` toQuery ("dryRun", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedDaemonSet FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteCollectionNamespacedDaemonSet GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedDaemonSet LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionNamespacedDaemonSet Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteCollectionNamespacedDaemonSet OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteCollectionNamespacedDaemonSet PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionNamespacedDaemonSet ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
instance HasOptionalParam DeleteCollectionNamespacedDaemonSet TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)
    
-- | @*/*@
instance MimeType mtype => Consumes DeleteCollectionNamespacedDaemonSet mtype

-- | @application/json@
instance Produces DeleteCollectionNamespacedDaemonSet MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionNamespacedDaemonSet MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces DeleteCollectionNamespacedDaemonSet MimeYaml


-- *** deleteCollectionNamespacedDeployment

-- | @DELETE \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/deployments@
-- 
-- delete collection of Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionNamespacedDeployment 
  :: (Consumes DeleteCollectionNamespacedDeployment contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest DeleteCollectionNamespacedDeployment contentType V1Status accept
deleteCollectionNamespacedDeployment _  _ (Namespace namespace) =
  _mkRequest "DELETE" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/deployments"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionNamespacedDeployment 
instance HasBodyParam DeleteCollectionNamespacedDeployment V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionNamespacedDeployment Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionNamespacedDeployment Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "dryRun" - When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
instance HasOptionalParam DeleteCollectionNamespacedDeployment DryRun where
  applyOptionalParam req (DryRun xs) =
    req `setQuery` toQuery ("dryRun", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedDeployment FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteCollectionNamespacedDeployment GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedDeployment LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionNamespacedDeployment Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteCollectionNamespacedDeployment OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteCollectionNamespacedDeployment PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionNamespacedDeployment ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
instance HasOptionalParam DeleteCollectionNamespacedDeployment TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)
    
-- | @*/*@
instance MimeType mtype => Consumes DeleteCollectionNamespacedDeployment mtype

-- | @application/json@
instance Produces DeleteCollectionNamespacedDeployment MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionNamespacedDeployment MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces DeleteCollectionNamespacedDeployment MimeYaml


-- *** deleteCollectionNamespacedIngress

-- | @DELETE \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/ingresses@
-- 
-- delete collection of Ingress
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionNamespacedIngress 
  :: (Consumes DeleteCollectionNamespacedIngress contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest DeleteCollectionNamespacedIngress contentType V1Status accept
deleteCollectionNamespacedIngress _  _ (Namespace namespace) =
  _mkRequest "DELETE" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/ingresses"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionNamespacedIngress 
instance HasBodyParam DeleteCollectionNamespacedIngress V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionNamespacedIngress Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionNamespacedIngress Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "dryRun" - When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
instance HasOptionalParam DeleteCollectionNamespacedIngress DryRun where
  applyOptionalParam req (DryRun xs) =
    req `setQuery` toQuery ("dryRun", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedIngress FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteCollectionNamespacedIngress GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedIngress LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionNamespacedIngress Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteCollectionNamespacedIngress OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteCollectionNamespacedIngress PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionNamespacedIngress ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
instance HasOptionalParam DeleteCollectionNamespacedIngress TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)
    
-- | @*/*@
instance MimeType mtype => Consumes DeleteCollectionNamespacedIngress mtype

-- | @application/json@
instance Produces DeleteCollectionNamespacedIngress MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionNamespacedIngress MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces DeleteCollectionNamespacedIngress MimeYaml


-- *** deleteCollectionNamespacedNetworkPolicy

-- | @DELETE \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/networkpolicies@
-- 
-- delete collection of NetworkPolicy
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionNamespacedNetworkPolicy 
  :: (Consumes DeleteCollectionNamespacedNetworkPolicy contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest DeleteCollectionNamespacedNetworkPolicy contentType V1Status accept
deleteCollectionNamespacedNetworkPolicy _  _ (Namespace namespace) =
  _mkRequest "DELETE" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/networkpolicies"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionNamespacedNetworkPolicy 
instance HasBodyParam DeleteCollectionNamespacedNetworkPolicy V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionNamespacedNetworkPolicy Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionNamespacedNetworkPolicy Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "dryRun" - When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
instance HasOptionalParam DeleteCollectionNamespacedNetworkPolicy DryRun where
  applyOptionalParam req (DryRun xs) =
    req `setQuery` toQuery ("dryRun", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedNetworkPolicy FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteCollectionNamespacedNetworkPolicy GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedNetworkPolicy LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionNamespacedNetworkPolicy Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteCollectionNamespacedNetworkPolicy OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteCollectionNamespacedNetworkPolicy PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionNamespacedNetworkPolicy ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
instance HasOptionalParam DeleteCollectionNamespacedNetworkPolicy TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)
    
-- | @*/*@
instance MimeType mtype => Consumes DeleteCollectionNamespacedNetworkPolicy mtype

-- | @application/json@
instance Produces DeleteCollectionNamespacedNetworkPolicy MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionNamespacedNetworkPolicy MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces DeleteCollectionNamespacedNetworkPolicy MimeYaml


-- *** deleteCollectionNamespacedReplicaSet

-- | @DELETE \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/replicasets@
-- 
-- delete collection of ReplicaSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionNamespacedReplicaSet 
  :: (Consumes DeleteCollectionNamespacedReplicaSet contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest DeleteCollectionNamespacedReplicaSet contentType V1Status accept
deleteCollectionNamespacedReplicaSet _  _ (Namespace namespace) =
  _mkRequest "DELETE" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/replicasets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionNamespacedReplicaSet 
instance HasBodyParam DeleteCollectionNamespacedReplicaSet V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionNamespacedReplicaSet Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionNamespacedReplicaSet Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "dryRun" - When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
instance HasOptionalParam DeleteCollectionNamespacedReplicaSet DryRun where
  applyOptionalParam req (DryRun xs) =
    req `setQuery` toQuery ("dryRun", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedReplicaSet FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteCollectionNamespacedReplicaSet GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedReplicaSet LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionNamespacedReplicaSet Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteCollectionNamespacedReplicaSet OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteCollectionNamespacedReplicaSet PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionNamespacedReplicaSet ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
instance HasOptionalParam DeleteCollectionNamespacedReplicaSet TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)
    
-- | @*/*@
instance MimeType mtype => Consumes DeleteCollectionNamespacedReplicaSet mtype

-- | @application/json@
instance Produces DeleteCollectionNamespacedReplicaSet MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionNamespacedReplicaSet MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces DeleteCollectionNamespacedReplicaSet MimeYaml


-- *** deleteCollectionPodSecurityPolicy

-- | @DELETE \/apis\/extensions\/v1beta1\/podsecuritypolicies@
-- 
-- delete collection of PodSecurityPolicy
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionPodSecurityPolicy 
  :: (Consumes DeleteCollectionPodSecurityPolicy contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest DeleteCollectionPodSecurityPolicy contentType V1Status accept
deleteCollectionPodSecurityPolicy _  _ =
  _mkRequest "DELETE" ["/apis/extensions/v1beta1/podsecuritypolicies"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionPodSecurityPolicy 
instance HasBodyParam DeleteCollectionPodSecurityPolicy V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionPodSecurityPolicy Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionPodSecurityPolicy Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "dryRun" - When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
instance HasOptionalParam DeleteCollectionPodSecurityPolicy DryRun where
  applyOptionalParam req (DryRun xs) =
    req `setQuery` toQuery ("dryRun", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionPodSecurityPolicy FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteCollectionPodSecurityPolicy GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionPodSecurityPolicy LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionPodSecurityPolicy Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteCollectionPodSecurityPolicy OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteCollectionPodSecurityPolicy PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionPodSecurityPolicy ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
instance HasOptionalParam DeleteCollectionPodSecurityPolicy TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)
    
-- | @*/*@
instance MimeType mtype => Consumes DeleteCollectionPodSecurityPolicy mtype

-- | @application/json@
instance Produces DeleteCollectionPodSecurityPolicy MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionPodSecurityPolicy MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces DeleteCollectionPodSecurityPolicy MimeYaml


-- *** deleteNamespacedDaemonSet

-- | @DELETE \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/daemonsets\/{name}@
-- 
-- delete a DaemonSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteNamespacedDaemonSet 
  :: (Consumes DeleteNamespacedDaemonSet contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the DaemonSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest DeleteNamespacedDaemonSet contentType V1Status accept
deleteNamespacedDaemonSet _  _ (Name name) (Namespace namespace) =
  _mkRequest "DELETE" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/daemonsets/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteNamespacedDaemonSet 
instance HasBodyParam DeleteNamespacedDaemonSet V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteNamespacedDaemonSet Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "dryRun" - When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
instance HasOptionalParam DeleteNamespacedDaemonSet DryRun where
  applyOptionalParam req (DryRun xs) =
    req `setQuery` toQuery ("dryRun", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteNamespacedDaemonSet GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteNamespacedDaemonSet OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteNamespacedDaemonSet PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)
    
-- | @*/*@
instance MimeType mtype => Consumes DeleteNamespacedDaemonSet mtype

-- | @application/json@
instance Produces DeleteNamespacedDaemonSet MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteNamespacedDaemonSet MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces DeleteNamespacedDaemonSet MimeYaml


-- *** deleteNamespacedDeployment

-- | @DELETE \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/deployments\/{name}@
-- 
-- delete a Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteNamespacedDeployment 
  :: (Consumes DeleteNamespacedDeployment contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Deployment
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest DeleteNamespacedDeployment contentType V1Status accept
deleteNamespacedDeployment _  _ (Name name) (Namespace namespace) =
  _mkRequest "DELETE" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/deployments/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteNamespacedDeployment 
instance HasBodyParam DeleteNamespacedDeployment V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteNamespacedDeployment Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "dryRun" - When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
instance HasOptionalParam DeleteNamespacedDeployment DryRun where
  applyOptionalParam req (DryRun xs) =
    req `setQuery` toQuery ("dryRun", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteNamespacedDeployment GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteNamespacedDeployment OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteNamespacedDeployment PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)
    
-- | @*/*@
instance MimeType mtype => Consumes DeleteNamespacedDeployment mtype

-- | @application/json@
instance Produces DeleteNamespacedDeployment MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteNamespacedDeployment MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces DeleteNamespacedDeployment MimeYaml


-- *** deleteNamespacedIngress

-- | @DELETE \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/ingresses\/{name}@
-- 
-- delete an Ingress
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteNamespacedIngress 
  :: (Consumes DeleteNamespacedIngress contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Ingress
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest DeleteNamespacedIngress contentType V1Status accept
deleteNamespacedIngress _  _ (Name name) (Namespace namespace) =
  _mkRequest "DELETE" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/ingresses/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteNamespacedIngress 
instance HasBodyParam DeleteNamespacedIngress V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteNamespacedIngress Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "dryRun" - When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
instance HasOptionalParam DeleteNamespacedIngress DryRun where
  applyOptionalParam req (DryRun xs) =
    req `setQuery` toQuery ("dryRun", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteNamespacedIngress GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteNamespacedIngress OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteNamespacedIngress PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)
    
-- | @*/*@
instance MimeType mtype => Consumes DeleteNamespacedIngress mtype

-- | @application/json@
instance Produces DeleteNamespacedIngress MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteNamespacedIngress MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces DeleteNamespacedIngress MimeYaml


-- *** deleteNamespacedNetworkPolicy

-- | @DELETE \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/networkpolicies\/{name}@
-- 
-- delete a NetworkPolicy
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteNamespacedNetworkPolicy 
  :: (Consumes DeleteNamespacedNetworkPolicy contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the NetworkPolicy
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest DeleteNamespacedNetworkPolicy contentType V1Status accept
deleteNamespacedNetworkPolicy _  _ (Name name) (Namespace namespace) =
  _mkRequest "DELETE" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/networkpolicies/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteNamespacedNetworkPolicy 
instance HasBodyParam DeleteNamespacedNetworkPolicy V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteNamespacedNetworkPolicy Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "dryRun" - When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
instance HasOptionalParam DeleteNamespacedNetworkPolicy DryRun where
  applyOptionalParam req (DryRun xs) =
    req `setQuery` toQuery ("dryRun", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteNamespacedNetworkPolicy GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteNamespacedNetworkPolicy OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteNamespacedNetworkPolicy PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)
    
-- | @*/*@
instance MimeType mtype => Consumes DeleteNamespacedNetworkPolicy mtype

-- | @application/json@
instance Produces DeleteNamespacedNetworkPolicy MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteNamespacedNetworkPolicy MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces DeleteNamespacedNetworkPolicy MimeYaml


-- *** deleteNamespacedReplicaSet

-- | @DELETE \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/replicasets\/{name}@
-- 
-- delete a ReplicaSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteNamespacedReplicaSet 
  :: (Consumes DeleteNamespacedReplicaSet contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ReplicaSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest DeleteNamespacedReplicaSet contentType V1Status accept
deleteNamespacedReplicaSet _  _ (Name name) (Namespace namespace) =
  _mkRequest "DELETE" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/replicasets/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteNamespacedReplicaSet 
instance HasBodyParam DeleteNamespacedReplicaSet V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteNamespacedReplicaSet Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "dryRun" - When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
instance HasOptionalParam DeleteNamespacedReplicaSet DryRun where
  applyOptionalParam req (DryRun xs) =
    req `setQuery` toQuery ("dryRun", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteNamespacedReplicaSet GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteNamespacedReplicaSet OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteNamespacedReplicaSet PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)
    
-- | @*/*@
instance MimeType mtype => Consumes DeleteNamespacedReplicaSet mtype

-- | @application/json@
instance Produces DeleteNamespacedReplicaSet MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteNamespacedReplicaSet MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces DeleteNamespacedReplicaSet MimeYaml


-- *** deletePodSecurityPolicy

-- | @DELETE \/apis\/extensions\/v1beta1\/podsecuritypolicies\/{name}@
-- 
-- delete a PodSecurityPolicy
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deletePodSecurityPolicy 
  :: (Consumes DeletePodSecurityPolicy contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the PodSecurityPolicy
  -> KubernetesRequest DeletePodSecurityPolicy contentType V1Status accept
deletePodSecurityPolicy _  _ (Name name) =
  _mkRequest "DELETE" ["/apis/extensions/v1beta1/podsecuritypolicies/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeletePodSecurityPolicy 
instance HasBodyParam DeletePodSecurityPolicy V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeletePodSecurityPolicy Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "dryRun" - When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
instance HasOptionalParam DeletePodSecurityPolicy DryRun where
  applyOptionalParam req (DryRun xs) =
    req `setQuery` toQuery ("dryRun", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeletePodSecurityPolicy GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeletePodSecurityPolicy OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeletePodSecurityPolicy PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)
    
-- | @*/*@
instance MimeType mtype => Consumes DeletePodSecurityPolicy mtype

-- | @application/json@
instance Produces DeletePodSecurityPolicy MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeletePodSecurityPolicy MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces DeletePodSecurityPolicy MimeYaml


-- *** getAPIResources

-- | @GET \/apis\/extensions\/v1beta1\/@
-- 
-- get available resources
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
getAPIResources 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest GetAPIResources MimeNoContent V1APIResourceList accept
getAPIResources  _ =
  _mkRequest "GET" ["/apis/extensions/v1beta1/"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data GetAPIResources  
-- | @application/json@
instance Produces GetAPIResources MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces GetAPIResources MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces GetAPIResources MimeYaml


-- *** listDaemonSetForAllNamespaces

-- | @GET \/apis\/extensions\/v1beta1\/daemonsets@
-- 
-- list or watch objects of kind DaemonSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listDaemonSetForAllNamespaces 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListDaemonSetForAllNamespaces MimeNoContent V1beta1DaemonSetList accept
listDaemonSetForAllNamespaces  _ =
  _mkRequest "GET" ["/apis/extensions/v1beta1/daemonsets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListDaemonSetForAllNamespaces  

-- | /Optional Param/ "allowWatchBookmarks" - allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.
instance HasOptionalParam ListDaemonSetForAllNamespaces AllowWatchBookmarks where
  applyOptionalParam req (AllowWatchBookmarks xs) =
    req `setQuery` toQuery ("allowWatchBookmarks", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListDaemonSetForAllNamespaces Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListDaemonSetForAllNamespaces FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListDaemonSetForAllNamespaces LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListDaemonSetForAllNamespaces Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListDaemonSetForAllNamespaces Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListDaemonSetForAllNamespaces ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
instance HasOptionalParam ListDaemonSetForAllNamespaces TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListDaemonSetForAllNamespaces Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)
-- | @application/json@
instance Produces ListDaemonSetForAllNamespaces MimeJSON
-- | @application/json;stream=watch@
instance Produces ListDaemonSetForAllNamespaces MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListDaemonSetForAllNamespaces MimeVndKubernetesProtobuf
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListDaemonSetForAllNamespaces MimeVndKubernetesProtobufstreamwatch
-- | @application/yaml@
instance Produces ListDaemonSetForAllNamespaces MimeYaml


-- *** listDeploymentForAllNamespaces

-- | @GET \/apis\/extensions\/v1beta1\/deployments@
-- 
-- list or watch objects of kind Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listDeploymentForAllNamespaces 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListDeploymentForAllNamespaces MimeNoContent ExtensionsV1beta1DeploymentList accept
listDeploymentForAllNamespaces  _ =
  _mkRequest "GET" ["/apis/extensions/v1beta1/deployments"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListDeploymentForAllNamespaces  

-- | /Optional Param/ "allowWatchBookmarks" - allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.
instance HasOptionalParam ListDeploymentForAllNamespaces AllowWatchBookmarks where
  applyOptionalParam req (AllowWatchBookmarks xs) =
    req `setQuery` toQuery ("allowWatchBookmarks", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListDeploymentForAllNamespaces Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListDeploymentForAllNamespaces FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListDeploymentForAllNamespaces LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListDeploymentForAllNamespaces Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListDeploymentForAllNamespaces Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListDeploymentForAllNamespaces ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
instance HasOptionalParam ListDeploymentForAllNamespaces TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListDeploymentForAllNamespaces Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)
-- | @application/json@
instance Produces ListDeploymentForAllNamespaces MimeJSON
-- | @application/json;stream=watch@
instance Produces ListDeploymentForAllNamespaces MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListDeploymentForAllNamespaces MimeVndKubernetesProtobuf
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListDeploymentForAllNamespaces MimeVndKubernetesProtobufstreamwatch
-- | @application/yaml@
instance Produces ListDeploymentForAllNamespaces MimeYaml


-- *** listIngressForAllNamespaces

-- | @GET \/apis\/extensions\/v1beta1\/ingresses@
-- 
-- list or watch objects of kind Ingress
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listIngressForAllNamespaces 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListIngressForAllNamespaces MimeNoContent ExtensionsV1beta1IngressList accept
listIngressForAllNamespaces  _ =
  _mkRequest "GET" ["/apis/extensions/v1beta1/ingresses"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListIngressForAllNamespaces  

-- | /Optional Param/ "allowWatchBookmarks" - allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.
instance HasOptionalParam ListIngressForAllNamespaces AllowWatchBookmarks where
  applyOptionalParam req (AllowWatchBookmarks xs) =
    req `setQuery` toQuery ("allowWatchBookmarks", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListIngressForAllNamespaces Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListIngressForAllNamespaces FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListIngressForAllNamespaces LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListIngressForAllNamespaces Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListIngressForAllNamespaces Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListIngressForAllNamespaces ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
instance HasOptionalParam ListIngressForAllNamespaces TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListIngressForAllNamespaces Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)
-- | @application/json@
instance Produces ListIngressForAllNamespaces MimeJSON
-- | @application/json;stream=watch@
instance Produces ListIngressForAllNamespaces MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListIngressForAllNamespaces MimeVndKubernetesProtobuf
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListIngressForAllNamespaces MimeVndKubernetesProtobufstreamwatch
-- | @application/yaml@
instance Produces ListIngressForAllNamespaces MimeYaml


-- *** listNamespacedDaemonSet

-- | @GET \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/daemonsets@
-- 
-- list or watch objects of kind DaemonSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listNamespacedDaemonSet 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ListNamespacedDaemonSet MimeNoContent V1beta1DaemonSetList accept
listNamespacedDaemonSet  _ (Namespace namespace) =
  _mkRequest "GET" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/daemonsets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListNamespacedDaemonSet  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListNamespacedDaemonSet Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "allowWatchBookmarks" - allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.
instance HasOptionalParam ListNamespacedDaemonSet AllowWatchBookmarks where
  applyOptionalParam req (AllowWatchBookmarks xs) =
    req `setQuery` toQuery ("allowWatchBookmarks", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListNamespacedDaemonSet Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListNamespacedDaemonSet FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListNamespacedDaemonSet LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListNamespacedDaemonSet Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListNamespacedDaemonSet ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
instance HasOptionalParam ListNamespacedDaemonSet TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListNamespacedDaemonSet Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)
-- | @application/json@
instance Produces ListNamespacedDaemonSet MimeJSON
-- | @application/json;stream=watch@
instance Produces ListNamespacedDaemonSet MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListNamespacedDaemonSet MimeVndKubernetesProtobuf
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListNamespacedDaemonSet MimeVndKubernetesProtobufstreamwatch
-- | @application/yaml@
instance Produces ListNamespacedDaemonSet MimeYaml


-- *** listNamespacedDeployment

-- | @GET \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/deployments@
-- 
-- list or watch objects of kind Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listNamespacedDeployment 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ListNamespacedDeployment MimeNoContent ExtensionsV1beta1DeploymentList accept
listNamespacedDeployment  _ (Namespace namespace) =
  _mkRequest "GET" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/deployments"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListNamespacedDeployment  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListNamespacedDeployment Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "allowWatchBookmarks" - allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.
instance HasOptionalParam ListNamespacedDeployment AllowWatchBookmarks where
  applyOptionalParam req (AllowWatchBookmarks xs) =
    req `setQuery` toQuery ("allowWatchBookmarks", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListNamespacedDeployment Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListNamespacedDeployment FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListNamespacedDeployment LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListNamespacedDeployment Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListNamespacedDeployment ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
instance HasOptionalParam ListNamespacedDeployment TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListNamespacedDeployment Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)
-- | @application/json@
instance Produces ListNamespacedDeployment MimeJSON
-- | @application/json;stream=watch@
instance Produces ListNamespacedDeployment MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListNamespacedDeployment MimeVndKubernetesProtobuf
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListNamespacedDeployment MimeVndKubernetesProtobufstreamwatch
-- | @application/yaml@
instance Produces ListNamespacedDeployment MimeYaml


-- *** listNamespacedIngress

-- | @GET \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/ingresses@
-- 
-- list or watch objects of kind Ingress
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listNamespacedIngress 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ListNamespacedIngress MimeNoContent ExtensionsV1beta1IngressList accept
listNamespacedIngress  _ (Namespace namespace) =
  _mkRequest "GET" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/ingresses"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListNamespacedIngress  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListNamespacedIngress Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "allowWatchBookmarks" - allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.
instance HasOptionalParam ListNamespacedIngress AllowWatchBookmarks where
  applyOptionalParam req (AllowWatchBookmarks xs) =
    req `setQuery` toQuery ("allowWatchBookmarks", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListNamespacedIngress Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListNamespacedIngress FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListNamespacedIngress LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListNamespacedIngress Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListNamespacedIngress ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
instance HasOptionalParam ListNamespacedIngress TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListNamespacedIngress Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)
-- | @application/json@
instance Produces ListNamespacedIngress MimeJSON
-- | @application/json;stream=watch@
instance Produces ListNamespacedIngress MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListNamespacedIngress MimeVndKubernetesProtobuf
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListNamespacedIngress MimeVndKubernetesProtobufstreamwatch
-- | @application/yaml@
instance Produces ListNamespacedIngress MimeYaml


-- *** listNamespacedNetworkPolicy

-- | @GET \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/networkpolicies@
-- 
-- list or watch objects of kind NetworkPolicy
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listNamespacedNetworkPolicy 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ListNamespacedNetworkPolicy MimeNoContent V1beta1NetworkPolicyList accept
listNamespacedNetworkPolicy  _ (Namespace namespace) =
  _mkRequest "GET" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/networkpolicies"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListNamespacedNetworkPolicy  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListNamespacedNetworkPolicy Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "allowWatchBookmarks" - allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.
instance HasOptionalParam ListNamespacedNetworkPolicy AllowWatchBookmarks where
  applyOptionalParam req (AllowWatchBookmarks xs) =
    req `setQuery` toQuery ("allowWatchBookmarks", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListNamespacedNetworkPolicy Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListNamespacedNetworkPolicy FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListNamespacedNetworkPolicy LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListNamespacedNetworkPolicy Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListNamespacedNetworkPolicy ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
instance HasOptionalParam ListNamespacedNetworkPolicy TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListNamespacedNetworkPolicy Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)
-- | @application/json@
instance Produces ListNamespacedNetworkPolicy MimeJSON
-- | @application/json;stream=watch@
instance Produces ListNamespacedNetworkPolicy MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListNamespacedNetworkPolicy MimeVndKubernetesProtobuf
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListNamespacedNetworkPolicy MimeVndKubernetesProtobufstreamwatch
-- | @application/yaml@
instance Produces ListNamespacedNetworkPolicy MimeYaml


-- *** listNamespacedReplicaSet

-- | @GET \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/replicasets@
-- 
-- list or watch objects of kind ReplicaSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listNamespacedReplicaSet 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ListNamespacedReplicaSet MimeNoContent V1beta1ReplicaSetList accept
listNamespacedReplicaSet  _ (Namespace namespace) =
  _mkRequest "GET" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/replicasets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListNamespacedReplicaSet  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListNamespacedReplicaSet Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "allowWatchBookmarks" - allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.
instance HasOptionalParam ListNamespacedReplicaSet AllowWatchBookmarks where
  applyOptionalParam req (AllowWatchBookmarks xs) =
    req `setQuery` toQuery ("allowWatchBookmarks", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListNamespacedReplicaSet Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListNamespacedReplicaSet FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListNamespacedReplicaSet LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListNamespacedReplicaSet Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListNamespacedReplicaSet ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
instance HasOptionalParam ListNamespacedReplicaSet TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListNamespacedReplicaSet Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)
-- | @application/json@
instance Produces ListNamespacedReplicaSet MimeJSON
-- | @application/json;stream=watch@
instance Produces ListNamespacedReplicaSet MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListNamespacedReplicaSet MimeVndKubernetesProtobuf
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListNamespacedReplicaSet MimeVndKubernetesProtobufstreamwatch
-- | @application/yaml@
instance Produces ListNamespacedReplicaSet MimeYaml


-- *** listNetworkPolicyForAllNamespaces

-- | @GET \/apis\/extensions\/v1beta1\/networkpolicies@
-- 
-- list or watch objects of kind NetworkPolicy
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listNetworkPolicyForAllNamespaces 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListNetworkPolicyForAllNamespaces MimeNoContent V1beta1NetworkPolicyList accept
listNetworkPolicyForAllNamespaces  _ =
  _mkRequest "GET" ["/apis/extensions/v1beta1/networkpolicies"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListNetworkPolicyForAllNamespaces  

-- | /Optional Param/ "allowWatchBookmarks" - allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.
instance HasOptionalParam ListNetworkPolicyForAllNamespaces AllowWatchBookmarks where
  applyOptionalParam req (AllowWatchBookmarks xs) =
    req `setQuery` toQuery ("allowWatchBookmarks", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListNetworkPolicyForAllNamespaces Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListNetworkPolicyForAllNamespaces FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListNetworkPolicyForAllNamespaces LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListNetworkPolicyForAllNamespaces Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListNetworkPolicyForAllNamespaces Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListNetworkPolicyForAllNamespaces ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
instance HasOptionalParam ListNetworkPolicyForAllNamespaces TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListNetworkPolicyForAllNamespaces Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)
-- | @application/json@
instance Produces ListNetworkPolicyForAllNamespaces MimeJSON
-- | @application/json;stream=watch@
instance Produces ListNetworkPolicyForAllNamespaces MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListNetworkPolicyForAllNamespaces MimeVndKubernetesProtobuf
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListNetworkPolicyForAllNamespaces MimeVndKubernetesProtobufstreamwatch
-- | @application/yaml@
instance Produces ListNetworkPolicyForAllNamespaces MimeYaml


-- *** listPodSecurityPolicy

-- | @GET \/apis\/extensions\/v1beta1\/podsecuritypolicies@
-- 
-- list or watch objects of kind PodSecurityPolicy
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listPodSecurityPolicy 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListPodSecurityPolicy MimeNoContent ExtensionsV1beta1PodSecurityPolicyList accept
listPodSecurityPolicy  _ =
  _mkRequest "GET" ["/apis/extensions/v1beta1/podsecuritypolicies"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListPodSecurityPolicy  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListPodSecurityPolicy Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "allowWatchBookmarks" - allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.
instance HasOptionalParam ListPodSecurityPolicy AllowWatchBookmarks where
  applyOptionalParam req (AllowWatchBookmarks xs) =
    req `setQuery` toQuery ("allowWatchBookmarks", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListPodSecurityPolicy Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListPodSecurityPolicy FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListPodSecurityPolicy LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListPodSecurityPolicy Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListPodSecurityPolicy ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
instance HasOptionalParam ListPodSecurityPolicy TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListPodSecurityPolicy Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)
-- | @application/json@
instance Produces ListPodSecurityPolicy MimeJSON
-- | @application/json;stream=watch@
instance Produces ListPodSecurityPolicy MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListPodSecurityPolicy MimeVndKubernetesProtobuf
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListPodSecurityPolicy MimeVndKubernetesProtobufstreamwatch
-- | @application/yaml@
instance Produces ListPodSecurityPolicy MimeYaml


-- *** listReplicaSetForAllNamespaces

-- | @GET \/apis\/extensions\/v1beta1\/replicasets@
-- 
-- list or watch objects of kind ReplicaSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listReplicaSetForAllNamespaces 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListReplicaSetForAllNamespaces MimeNoContent V1beta1ReplicaSetList accept
listReplicaSetForAllNamespaces  _ =
  _mkRequest "GET" ["/apis/extensions/v1beta1/replicasets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListReplicaSetForAllNamespaces  

-- | /Optional Param/ "allowWatchBookmarks" - allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.
instance HasOptionalParam ListReplicaSetForAllNamespaces AllowWatchBookmarks where
  applyOptionalParam req (AllowWatchBookmarks xs) =
    req `setQuery` toQuery ("allowWatchBookmarks", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListReplicaSetForAllNamespaces Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListReplicaSetForAllNamespaces FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListReplicaSetForAllNamespaces LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListReplicaSetForAllNamespaces Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListReplicaSetForAllNamespaces Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListReplicaSetForAllNamespaces ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
instance HasOptionalParam ListReplicaSetForAllNamespaces TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListReplicaSetForAllNamespaces Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)
-- | @application/json@
instance Produces ListReplicaSetForAllNamespaces MimeJSON
-- | @application/json;stream=watch@
instance Produces ListReplicaSetForAllNamespaces MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListReplicaSetForAllNamespaces MimeVndKubernetesProtobuf
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListReplicaSetForAllNamespaces MimeVndKubernetesProtobufstreamwatch
-- | @application/yaml@
instance Produces ListReplicaSetForAllNamespaces MimeYaml


-- *** patchNamespacedDaemonSet

-- | @PATCH \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/daemonsets\/{name}@
-- 
-- partially update the specified DaemonSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedDaemonSet 
  :: (Consumes PatchNamespacedDaemonSet contentType, MimeRender contentType Body)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Body -- ^ "body"
  -> Name -- ^ "name" -  name of the DaemonSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest PatchNamespacedDaemonSet contentType V1beta1DaemonSet accept
patchNamespacedDaemonSet _  _ body (Name name) (Namespace namespace) =
  _mkRequest "PATCH" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/daemonsets/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedDaemonSet 
instance HasBodyParam PatchNamespacedDaemonSet Body 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedDaemonSet Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "dryRun" - When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
instance HasOptionalParam PatchNamespacedDaemonSet DryRun where
  applyOptionalParam req (DryRun xs) =
    req `setQuery` toQuery ("dryRun", Just xs)

-- | /Optional Param/ "fieldManager" - fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
instance HasOptionalParam PatchNamespacedDaemonSet FieldManager where
  applyOptionalParam req (FieldManager xs) =
    req `setQuery` toQuery ("fieldManager", Just xs)

-- | /Optional Param/ "force" - Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
instance HasOptionalParam PatchNamespacedDaemonSet Force where
  applyOptionalParam req (Force xs) =
    req `setQuery` toQuery ("force", Just xs)

-- | @application/apply-patch+yaml@
instance Consumes PatchNamespacedDaemonSet MimeApplyPatchyaml
-- | @application/json-patch+json@
instance Consumes PatchNamespacedDaemonSet MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedDaemonSet MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedDaemonSet MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedDaemonSet MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedDaemonSet MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces PatchNamespacedDaemonSet MimeYaml


-- *** patchNamespacedDaemonSetStatus

-- | @PATCH \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/daemonsets\/{name}\/status@
-- 
-- partially update status of the specified DaemonSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedDaemonSetStatus 
  :: (Consumes PatchNamespacedDaemonSetStatus contentType, MimeRender contentType Body)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Body -- ^ "body"
  -> Name -- ^ "name" -  name of the DaemonSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest PatchNamespacedDaemonSetStatus contentType V1beta1DaemonSet accept
patchNamespacedDaemonSetStatus _  _ body (Name name) (Namespace namespace) =
  _mkRequest "PATCH" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/daemonsets/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedDaemonSetStatus 
instance HasBodyParam PatchNamespacedDaemonSetStatus Body 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedDaemonSetStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "dryRun" - When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
instance HasOptionalParam PatchNamespacedDaemonSetStatus DryRun where
  applyOptionalParam req (DryRun xs) =
    req `setQuery` toQuery ("dryRun", Just xs)

-- | /Optional Param/ "fieldManager" - fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
instance HasOptionalParam PatchNamespacedDaemonSetStatus FieldManager where
  applyOptionalParam req (FieldManager xs) =
    req `setQuery` toQuery ("fieldManager", Just xs)

-- | /Optional Param/ "force" - Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
instance HasOptionalParam PatchNamespacedDaemonSetStatus Force where
  applyOptionalParam req (Force xs) =
    req `setQuery` toQuery ("force", Just xs)

-- | @application/apply-patch+yaml@
instance Consumes PatchNamespacedDaemonSetStatus MimeApplyPatchyaml
-- | @application/json-patch+json@
instance Consumes PatchNamespacedDaemonSetStatus MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedDaemonSetStatus MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedDaemonSetStatus MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedDaemonSetStatus MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedDaemonSetStatus MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces PatchNamespacedDaemonSetStatus MimeYaml


-- *** patchNamespacedDeployment

-- | @PATCH \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/deployments\/{name}@
-- 
-- partially update the specified Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedDeployment 
  :: (Consumes PatchNamespacedDeployment contentType, MimeRender contentType Body)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Body -- ^ "body"
  -> Name -- ^ "name" -  name of the Deployment
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest PatchNamespacedDeployment contentType ExtensionsV1beta1Deployment accept
patchNamespacedDeployment _  _ body (Name name) (Namespace namespace) =
  _mkRequest "PATCH" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/deployments/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedDeployment 
instance HasBodyParam PatchNamespacedDeployment Body 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedDeployment Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "dryRun" - When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
instance HasOptionalParam PatchNamespacedDeployment DryRun where
  applyOptionalParam req (DryRun xs) =
    req `setQuery` toQuery ("dryRun", Just xs)

-- | /Optional Param/ "fieldManager" - fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
instance HasOptionalParam PatchNamespacedDeployment FieldManager where
  applyOptionalParam req (FieldManager xs) =
    req `setQuery` toQuery ("fieldManager", Just xs)

-- | /Optional Param/ "force" - Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
instance HasOptionalParam PatchNamespacedDeployment Force where
  applyOptionalParam req (Force xs) =
    req `setQuery` toQuery ("force", Just xs)

-- | @application/apply-patch+yaml@
instance Consumes PatchNamespacedDeployment MimeApplyPatchyaml
-- | @application/json-patch+json@
instance Consumes PatchNamespacedDeployment MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedDeployment MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedDeployment MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedDeployment MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedDeployment MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces PatchNamespacedDeployment MimeYaml


-- *** patchNamespacedDeploymentScale

-- | @PATCH \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/deployments\/{name}\/scale@
-- 
-- partially update scale of the specified Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedDeploymentScale 
  :: (Consumes PatchNamespacedDeploymentScale contentType, MimeRender contentType Body)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Body -- ^ "body"
  -> Name -- ^ "name" -  name of the Scale
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest PatchNamespacedDeploymentScale contentType ExtensionsV1beta1Scale accept
patchNamespacedDeploymentScale _  _ body (Name name) (Namespace namespace) =
  _mkRequest "PATCH" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/deployments/",toPath name,"/scale"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedDeploymentScale 
instance HasBodyParam PatchNamespacedDeploymentScale Body 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedDeploymentScale Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "dryRun" - When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
instance HasOptionalParam PatchNamespacedDeploymentScale DryRun where
  applyOptionalParam req (DryRun xs) =
    req `setQuery` toQuery ("dryRun", Just xs)

-- | /Optional Param/ "fieldManager" - fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
instance HasOptionalParam PatchNamespacedDeploymentScale FieldManager where
  applyOptionalParam req (FieldManager xs) =
    req `setQuery` toQuery ("fieldManager", Just xs)

-- | /Optional Param/ "force" - Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
instance HasOptionalParam PatchNamespacedDeploymentScale Force where
  applyOptionalParam req (Force xs) =
    req `setQuery` toQuery ("force", Just xs)

-- | @application/apply-patch+yaml@
instance Consumes PatchNamespacedDeploymentScale MimeApplyPatchyaml
-- | @application/json-patch+json@
instance Consumes PatchNamespacedDeploymentScale MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedDeploymentScale MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedDeploymentScale MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedDeploymentScale MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedDeploymentScale MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces PatchNamespacedDeploymentScale MimeYaml


-- *** patchNamespacedDeploymentStatus

-- | @PATCH \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/deployments\/{name}\/status@
-- 
-- partially update status of the specified Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedDeploymentStatus 
  :: (Consumes PatchNamespacedDeploymentStatus contentType, MimeRender contentType Body)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Body -- ^ "body"
  -> Name -- ^ "name" -  name of the Deployment
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest PatchNamespacedDeploymentStatus contentType ExtensionsV1beta1Deployment accept
patchNamespacedDeploymentStatus _  _ body (Name name) (Namespace namespace) =
  _mkRequest "PATCH" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/deployments/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedDeploymentStatus 
instance HasBodyParam PatchNamespacedDeploymentStatus Body 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedDeploymentStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "dryRun" - When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
instance HasOptionalParam PatchNamespacedDeploymentStatus DryRun where
  applyOptionalParam req (DryRun xs) =
    req `setQuery` toQuery ("dryRun", Just xs)

-- | /Optional Param/ "fieldManager" - fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
instance HasOptionalParam PatchNamespacedDeploymentStatus FieldManager where
  applyOptionalParam req (FieldManager xs) =
    req `setQuery` toQuery ("fieldManager", Just xs)

-- | /Optional Param/ "force" - Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
instance HasOptionalParam PatchNamespacedDeploymentStatus Force where
  applyOptionalParam req (Force xs) =
    req `setQuery` toQuery ("force", Just xs)

-- | @application/apply-patch+yaml@
instance Consumes PatchNamespacedDeploymentStatus MimeApplyPatchyaml
-- | @application/json-patch+json@
instance Consumes PatchNamespacedDeploymentStatus MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedDeploymentStatus MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedDeploymentStatus MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedDeploymentStatus MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedDeploymentStatus MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces PatchNamespacedDeploymentStatus MimeYaml


-- *** patchNamespacedIngress

-- | @PATCH \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/ingresses\/{name}@
-- 
-- partially update the specified Ingress
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedIngress 
  :: (Consumes PatchNamespacedIngress contentType, MimeRender contentType Body)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Body -- ^ "body"
  -> Name -- ^ "name" -  name of the Ingress
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest PatchNamespacedIngress contentType ExtensionsV1beta1Ingress accept
patchNamespacedIngress _  _ body (Name name) (Namespace namespace) =
  _mkRequest "PATCH" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/ingresses/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedIngress 
instance HasBodyParam PatchNamespacedIngress Body 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedIngress Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "dryRun" - When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
instance HasOptionalParam PatchNamespacedIngress DryRun where
  applyOptionalParam req (DryRun xs) =
    req `setQuery` toQuery ("dryRun", Just xs)

-- | /Optional Param/ "fieldManager" - fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
instance HasOptionalParam PatchNamespacedIngress FieldManager where
  applyOptionalParam req (FieldManager xs) =
    req `setQuery` toQuery ("fieldManager", Just xs)

-- | /Optional Param/ "force" - Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
instance HasOptionalParam PatchNamespacedIngress Force where
  applyOptionalParam req (Force xs) =
    req `setQuery` toQuery ("force", Just xs)

-- | @application/apply-patch+yaml@
instance Consumes PatchNamespacedIngress MimeApplyPatchyaml
-- | @application/json-patch+json@
instance Consumes PatchNamespacedIngress MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedIngress MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedIngress MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedIngress MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedIngress MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces PatchNamespacedIngress MimeYaml


-- *** patchNamespacedIngressStatus

-- | @PATCH \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/ingresses\/{name}\/status@
-- 
-- partially update status of the specified Ingress
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedIngressStatus 
  :: (Consumes PatchNamespacedIngressStatus contentType, MimeRender contentType Body)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Body -- ^ "body"
  -> Name -- ^ "name" -  name of the Ingress
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest PatchNamespacedIngressStatus contentType ExtensionsV1beta1Ingress accept
patchNamespacedIngressStatus _  _ body (Name name) (Namespace namespace) =
  _mkRequest "PATCH" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/ingresses/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedIngressStatus 
instance HasBodyParam PatchNamespacedIngressStatus Body 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedIngressStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "dryRun" - When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
instance HasOptionalParam PatchNamespacedIngressStatus DryRun where
  applyOptionalParam req (DryRun xs) =
    req `setQuery` toQuery ("dryRun", Just xs)

-- | /Optional Param/ "fieldManager" - fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
instance HasOptionalParam PatchNamespacedIngressStatus FieldManager where
  applyOptionalParam req (FieldManager xs) =
    req `setQuery` toQuery ("fieldManager", Just xs)

-- | /Optional Param/ "force" - Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
instance HasOptionalParam PatchNamespacedIngressStatus Force where
  applyOptionalParam req (Force xs) =
    req `setQuery` toQuery ("force", Just xs)

-- | @application/apply-patch+yaml@
instance Consumes PatchNamespacedIngressStatus MimeApplyPatchyaml
-- | @application/json-patch+json@
instance Consumes PatchNamespacedIngressStatus MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedIngressStatus MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedIngressStatus MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedIngressStatus MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedIngressStatus MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces PatchNamespacedIngressStatus MimeYaml


-- *** patchNamespacedNetworkPolicy

-- | @PATCH \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/networkpolicies\/{name}@
-- 
-- partially update the specified NetworkPolicy
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedNetworkPolicy 
  :: (Consumes PatchNamespacedNetworkPolicy contentType, MimeRender contentType Body)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Body -- ^ "body"
  -> Name -- ^ "name" -  name of the NetworkPolicy
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest PatchNamespacedNetworkPolicy contentType V1beta1NetworkPolicy accept
patchNamespacedNetworkPolicy _  _ body (Name name) (Namespace namespace) =
  _mkRequest "PATCH" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/networkpolicies/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedNetworkPolicy 
instance HasBodyParam PatchNamespacedNetworkPolicy Body 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedNetworkPolicy Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "dryRun" - When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
instance HasOptionalParam PatchNamespacedNetworkPolicy DryRun where
  applyOptionalParam req (DryRun xs) =
    req `setQuery` toQuery ("dryRun", Just xs)

-- | /Optional Param/ "fieldManager" - fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
instance HasOptionalParam PatchNamespacedNetworkPolicy FieldManager where
  applyOptionalParam req (FieldManager xs) =
    req `setQuery` toQuery ("fieldManager", Just xs)

-- | /Optional Param/ "force" - Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
instance HasOptionalParam PatchNamespacedNetworkPolicy Force where
  applyOptionalParam req (Force xs) =
    req `setQuery` toQuery ("force", Just xs)

-- | @application/apply-patch+yaml@
instance Consumes PatchNamespacedNetworkPolicy MimeApplyPatchyaml
-- | @application/json-patch+json@
instance Consumes PatchNamespacedNetworkPolicy MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedNetworkPolicy MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedNetworkPolicy MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedNetworkPolicy MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedNetworkPolicy MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces PatchNamespacedNetworkPolicy MimeYaml


-- *** patchNamespacedReplicaSet

-- | @PATCH \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/replicasets\/{name}@
-- 
-- partially update the specified ReplicaSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedReplicaSet 
  :: (Consumes PatchNamespacedReplicaSet contentType, MimeRender contentType Body)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Body -- ^ "body"
  -> Name -- ^ "name" -  name of the ReplicaSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest PatchNamespacedReplicaSet contentType V1beta1ReplicaSet accept
patchNamespacedReplicaSet _  _ body (Name name) (Namespace namespace) =
  _mkRequest "PATCH" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/replicasets/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedReplicaSet 
instance HasBodyParam PatchNamespacedReplicaSet Body 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedReplicaSet Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "dryRun" - When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
instance HasOptionalParam PatchNamespacedReplicaSet DryRun where
  applyOptionalParam req (DryRun xs) =
    req `setQuery` toQuery ("dryRun", Just xs)

-- | /Optional Param/ "fieldManager" - fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
instance HasOptionalParam PatchNamespacedReplicaSet FieldManager where
  applyOptionalParam req (FieldManager xs) =
    req `setQuery` toQuery ("fieldManager", Just xs)

-- | /Optional Param/ "force" - Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
instance HasOptionalParam PatchNamespacedReplicaSet Force where
  applyOptionalParam req (Force xs) =
    req `setQuery` toQuery ("force", Just xs)

-- | @application/apply-patch+yaml@
instance Consumes PatchNamespacedReplicaSet MimeApplyPatchyaml
-- | @application/json-patch+json@
instance Consumes PatchNamespacedReplicaSet MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedReplicaSet MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedReplicaSet MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedReplicaSet MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedReplicaSet MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces PatchNamespacedReplicaSet MimeYaml


-- *** patchNamespacedReplicaSetScale

-- | @PATCH \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/replicasets\/{name}\/scale@
-- 
-- partially update scale of the specified ReplicaSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedReplicaSetScale 
  :: (Consumes PatchNamespacedReplicaSetScale contentType, MimeRender contentType Body)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Body -- ^ "body"
  -> Name -- ^ "name" -  name of the Scale
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest PatchNamespacedReplicaSetScale contentType ExtensionsV1beta1Scale accept
patchNamespacedReplicaSetScale _  _ body (Name name) (Namespace namespace) =
  _mkRequest "PATCH" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/replicasets/",toPath name,"/scale"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedReplicaSetScale 
instance HasBodyParam PatchNamespacedReplicaSetScale Body 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedReplicaSetScale Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "dryRun" - When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
instance HasOptionalParam PatchNamespacedReplicaSetScale DryRun where
  applyOptionalParam req (DryRun xs) =
    req `setQuery` toQuery ("dryRun", Just xs)

-- | /Optional Param/ "fieldManager" - fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
instance HasOptionalParam PatchNamespacedReplicaSetScale FieldManager where
  applyOptionalParam req (FieldManager xs) =
    req `setQuery` toQuery ("fieldManager", Just xs)

-- | /Optional Param/ "force" - Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
instance HasOptionalParam PatchNamespacedReplicaSetScale Force where
  applyOptionalParam req (Force xs) =
    req `setQuery` toQuery ("force", Just xs)

-- | @application/apply-patch+yaml@
instance Consumes PatchNamespacedReplicaSetScale MimeApplyPatchyaml
-- | @application/json-patch+json@
instance Consumes PatchNamespacedReplicaSetScale MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedReplicaSetScale MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedReplicaSetScale MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedReplicaSetScale MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedReplicaSetScale MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces PatchNamespacedReplicaSetScale MimeYaml


-- *** patchNamespacedReplicaSetStatus

-- | @PATCH \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/replicasets\/{name}\/status@
-- 
-- partially update status of the specified ReplicaSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedReplicaSetStatus 
  :: (Consumes PatchNamespacedReplicaSetStatus contentType, MimeRender contentType Body)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Body -- ^ "body"
  -> Name -- ^ "name" -  name of the ReplicaSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest PatchNamespacedReplicaSetStatus contentType V1beta1ReplicaSet accept
patchNamespacedReplicaSetStatus _  _ body (Name name) (Namespace namespace) =
  _mkRequest "PATCH" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/replicasets/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedReplicaSetStatus 
instance HasBodyParam PatchNamespacedReplicaSetStatus Body 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedReplicaSetStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "dryRun" - When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
instance HasOptionalParam PatchNamespacedReplicaSetStatus DryRun where
  applyOptionalParam req (DryRun xs) =
    req `setQuery` toQuery ("dryRun", Just xs)

-- | /Optional Param/ "fieldManager" - fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
instance HasOptionalParam PatchNamespacedReplicaSetStatus FieldManager where
  applyOptionalParam req (FieldManager xs) =
    req `setQuery` toQuery ("fieldManager", Just xs)

-- | /Optional Param/ "force" - Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
instance HasOptionalParam PatchNamespacedReplicaSetStatus Force where
  applyOptionalParam req (Force xs) =
    req `setQuery` toQuery ("force", Just xs)

-- | @application/apply-patch+yaml@
instance Consumes PatchNamespacedReplicaSetStatus MimeApplyPatchyaml
-- | @application/json-patch+json@
instance Consumes PatchNamespacedReplicaSetStatus MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedReplicaSetStatus MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedReplicaSetStatus MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedReplicaSetStatus MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedReplicaSetStatus MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces PatchNamespacedReplicaSetStatus MimeYaml


-- *** patchNamespacedReplicationControllerDummyScale

-- | @PATCH \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/replicationcontrollers\/{name}\/scale@
-- 
-- partially update scale of the specified ReplicationControllerDummy
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedReplicationControllerDummyScale 
  :: (Consumes PatchNamespacedReplicationControllerDummyScale contentType, MimeRender contentType Body)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Body -- ^ "body"
  -> Name -- ^ "name" -  name of the Scale
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest PatchNamespacedReplicationControllerDummyScale contentType ExtensionsV1beta1Scale accept
patchNamespacedReplicationControllerDummyScale _  _ body (Name name) (Namespace namespace) =
  _mkRequest "PATCH" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/replicationcontrollers/",toPath name,"/scale"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedReplicationControllerDummyScale 
instance HasBodyParam PatchNamespacedReplicationControllerDummyScale Body 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedReplicationControllerDummyScale Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "dryRun" - When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
instance HasOptionalParam PatchNamespacedReplicationControllerDummyScale DryRun where
  applyOptionalParam req (DryRun xs) =
    req `setQuery` toQuery ("dryRun", Just xs)

-- | /Optional Param/ "fieldManager" - fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
instance HasOptionalParam PatchNamespacedReplicationControllerDummyScale FieldManager where
  applyOptionalParam req (FieldManager xs) =
    req `setQuery` toQuery ("fieldManager", Just xs)

-- | /Optional Param/ "force" - Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
instance HasOptionalParam PatchNamespacedReplicationControllerDummyScale Force where
  applyOptionalParam req (Force xs) =
    req `setQuery` toQuery ("force", Just xs)

-- | @application/apply-patch+yaml@
instance Consumes PatchNamespacedReplicationControllerDummyScale MimeApplyPatchyaml
-- | @application/json-patch+json@
instance Consumes PatchNamespacedReplicationControllerDummyScale MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedReplicationControllerDummyScale MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedReplicationControllerDummyScale MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedReplicationControllerDummyScale MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedReplicationControllerDummyScale MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces PatchNamespacedReplicationControllerDummyScale MimeYaml


-- *** patchPodSecurityPolicy

-- | @PATCH \/apis\/extensions\/v1beta1\/podsecuritypolicies\/{name}@
-- 
-- partially update the specified PodSecurityPolicy
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchPodSecurityPolicy 
  :: (Consumes PatchPodSecurityPolicy contentType, MimeRender contentType Body)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Body -- ^ "body"
  -> Name -- ^ "name" -  name of the PodSecurityPolicy
  -> KubernetesRequest PatchPodSecurityPolicy contentType ExtensionsV1beta1PodSecurityPolicy accept
patchPodSecurityPolicy _  _ body (Name name) =
  _mkRequest "PATCH" ["/apis/extensions/v1beta1/podsecuritypolicies/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchPodSecurityPolicy 
instance HasBodyParam PatchPodSecurityPolicy Body 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchPodSecurityPolicy Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "dryRun" - When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
instance HasOptionalParam PatchPodSecurityPolicy DryRun where
  applyOptionalParam req (DryRun xs) =
    req `setQuery` toQuery ("dryRun", Just xs)

-- | /Optional Param/ "fieldManager" - fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
instance HasOptionalParam PatchPodSecurityPolicy FieldManager where
  applyOptionalParam req (FieldManager xs) =
    req `setQuery` toQuery ("fieldManager", Just xs)

-- | /Optional Param/ "force" - Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
instance HasOptionalParam PatchPodSecurityPolicy Force where
  applyOptionalParam req (Force xs) =
    req `setQuery` toQuery ("force", Just xs)

-- | @application/apply-patch+yaml@
instance Consumes PatchPodSecurityPolicy MimeApplyPatchyaml
-- | @application/json-patch+json@
instance Consumes PatchPodSecurityPolicy MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchPodSecurityPolicy MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchPodSecurityPolicy MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchPodSecurityPolicy MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchPodSecurityPolicy MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces PatchPodSecurityPolicy MimeYaml


-- *** readNamespacedDaemonSet

-- | @GET \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/daemonsets\/{name}@
-- 
-- read the specified DaemonSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedDaemonSet 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the DaemonSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedDaemonSet MimeNoContent V1beta1DaemonSet accept
readNamespacedDaemonSet  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/daemonsets/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedDaemonSet  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedDaemonSet Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "exact" - Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'. Deprecated. Planned for removal in 1.18.
instance HasOptionalParam ReadNamespacedDaemonSet Exact where
  applyOptionalParam req (Exact xs) =
    req `setQuery` toQuery ("exact", Just xs)

-- | /Optional Param/ "export" - Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
instance HasOptionalParam ReadNamespacedDaemonSet Export where
  applyOptionalParam req (Export xs) =
    req `setQuery` toQuery ("export", Just xs)
-- | @application/json@
instance Produces ReadNamespacedDaemonSet MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedDaemonSet MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces ReadNamespacedDaemonSet MimeYaml


-- *** readNamespacedDaemonSetStatus

-- | @GET \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/daemonsets\/{name}\/status@
-- 
-- read status of the specified DaemonSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedDaemonSetStatus 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the DaemonSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedDaemonSetStatus MimeNoContent V1beta1DaemonSet accept
readNamespacedDaemonSetStatus  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/daemonsets/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedDaemonSetStatus  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedDaemonSetStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)
-- | @application/json@
instance Produces ReadNamespacedDaemonSetStatus MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedDaemonSetStatus MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces ReadNamespacedDaemonSetStatus MimeYaml


-- *** readNamespacedDeployment

-- | @GET \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/deployments\/{name}@
-- 
-- read the specified Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedDeployment 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Deployment
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedDeployment MimeNoContent ExtensionsV1beta1Deployment accept
readNamespacedDeployment  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/deployments/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedDeployment  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedDeployment Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "exact" - Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'. Deprecated. Planned for removal in 1.18.
instance HasOptionalParam ReadNamespacedDeployment Exact where
  applyOptionalParam req (Exact xs) =
    req `setQuery` toQuery ("exact", Just xs)

-- | /Optional Param/ "export" - Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
instance HasOptionalParam ReadNamespacedDeployment Export where
  applyOptionalParam req (Export xs) =
    req `setQuery` toQuery ("export", Just xs)
-- | @application/json@
instance Produces ReadNamespacedDeployment MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedDeployment MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces ReadNamespacedDeployment MimeYaml


-- *** readNamespacedDeploymentScale

-- | @GET \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/deployments\/{name}\/scale@
-- 
-- read scale of the specified Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedDeploymentScale 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Scale
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedDeploymentScale MimeNoContent ExtensionsV1beta1Scale accept
readNamespacedDeploymentScale  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/deployments/",toPath name,"/scale"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedDeploymentScale  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedDeploymentScale Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)
-- | @application/json@
instance Produces ReadNamespacedDeploymentScale MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedDeploymentScale MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces ReadNamespacedDeploymentScale MimeYaml


-- *** readNamespacedDeploymentStatus

-- | @GET \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/deployments\/{name}\/status@
-- 
-- read status of the specified Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedDeploymentStatus 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Deployment
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedDeploymentStatus MimeNoContent ExtensionsV1beta1Deployment accept
readNamespacedDeploymentStatus  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/deployments/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedDeploymentStatus  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedDeploymentStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)
-- | @application/json@
instance Produces ReadNamespacedDeploymentStatus MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedDeploymentStatus MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces ReadNamespacedDeploymentStatus MimeYaml


-- *** readNamespacedIngress

-- | @GET \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/ingresses\/{name}@
-- 
-- read the specified Ingress
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedIngress 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Ingress
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedIngress MimeNoContent ExtensionsV1beta1Ingress accept
readNamespacedIngress  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/ingresses/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedIngress  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedIngress Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "exact" - Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'. Deprecated. Planned for removal in 1.18.
instance HasOptionalParam ReadNamespacedIngress Exact where
  applyOptionalParam req (Exact xs) =
    req `setQuery` toQuery ("exact", Just xs)

-- | /Optional Param/ "export" - Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
instance HasOptionalParam ReadNamespacedIngress Export where
  applyOptionalParam req (Export xs) =
    req `setQuery` toQuery ("export", Just xs)
-- | @application/json@
instance Produces ReadNamespacedIngress MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedIngress MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces ReadNamespacedIngress MimeYaml


-- *** readNamespacedIngressStatus

-- | @GET \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/ingresses\/{name}\/status@
-- 
-- read status of the specified Ingress
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedIngressStatus 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Ingress
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedIngressStatus MimeNoContent ExtensionsV1beta1Ingress accept
readNamespacedIngressStatus  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/ingresses/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedIngressStatus  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedIngressStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)
-- | @application/json@
instance Produces ReadNamespacedIngressStatus MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedIngressStatus MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces ReadNamespacedIngressStatus MimeYaml


-- *** readNamespacedNetworkPolicy

-- | @GET \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/networkpolicies\/{name}@
-- 
-- read the specified NetworkPolicy
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedNetworkPolicy 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the NetworkPolicy
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedNetworkPolicy MimeNoContent V1beta1NetworkPolicy accept
readNamespacedNetworkPolicy  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/networkpolicies/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedNetworkPolicy  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedNetworkPolicy Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "exact" - Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'. Deprecated. Planned for removal in 1.18.
instance HasOptionalParam ReadNamespacedNetworkPolicy Exact where
  applyOptionalParam req (Exact xs) =
    req `setQuery` toQuery ("exact", Just xs)

-- | /Optional Param/ "export" - Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
instance HasOptionalParam ReadNamespacedNetworkPolicy Export where
  applyOptionalParam req (Export xs) =
    req `setQuery` toQuery ("export", Just xs)
-- | @application/json@
instance Produces ReadNamespacedNetworkPolicy MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedNetworkPolicy MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces ReadNamespacedNetworkPolicy MimeYaml


-- *** readNamespacedReplicaSet

-- | @GET \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/replicasets\/{name}@
-- 
-- read the specified ReplicaSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedReplicaSet 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ReplicaSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedReplicaSet MimeNoContent V1beta1ReplicaSet accept
readNamespacedReplicaSet  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/replicasets/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedReplicaSet  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedReplicaSet Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "exact" - Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'. Deprecated. Planned for removal in 1.18.
instance HasOptionalParam ReadNamespacedReplicaSet Exact where
  applyOptionalParam req (Exact xs) =
    req `setQuery` toQuery ("exact", Just xs)

-- | /Optional Param/ "export" - Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
instance HasOptionalParam ReadNamespacedReplicaSet Export where
  applyOptionalParam req (Export xs) =
    req `setQuery` toQuery ("export", Just xs)
-- | @application/json@
instance Produces ReadNamespacedReplicaSet MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedReplicaSet MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces ReadNamespacedReplicaSet MimeYaml


-- *** readNamespacedReplicaSetScale

-- | @GET \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/replicasets\/{name}\/scale@
-- 
-- read scale of the specified ReplicaSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedReplicaSetScale 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Scale
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedReplicaSetScale MimeNoContent ExtensionsV1beta1Scale accept
readNamespacedReplicaSetScale  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/replicasets/",toPath name,"/scale"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedReplicaSetScale  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedReplicaSetScale Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)
-- | @application/json@
instance Produces ReadNamespacedReplicaSetScale MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedReplicaSetScale MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces ReadNamespacedReplicaSetScale MimeYaml


-- *** readNamespacedReplicaSetStatus

-- | @GET \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/replicasets\/{name}\/status@
-- 
-- read status of the specified ReplicaSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedReplicaSetStatus 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ReplicaSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedReplicaSetStatus MimeNoContent V1beta1ReplicaSet accept
readNamespacedReplicaSetStatus  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/replicasets/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedReplicaSetStatus  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedReplicaSetStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)
-- | @application/json@
instance Produces ReadNamespacedReplicaSetStatus MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedReplicaSetStatus MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces ReadNamespacedReplicaSetStatus MimeYaml


-- *** readNamespacedReplicationControllerDummyScale

-- | @GET \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/replicationcontrollers\/{name}\/scale@
-- 
-- read scale of the specified ReplicationControllerDummy
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedReplicationControllerDummyScale 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Scale
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedReplicationControllerDummyScale MimeNoContent ExtensionsV1beta1Scale accept
readNamespacedReplicationControllerDummyScale  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/replicationcontrollers/",toPath name,"/scale"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedReplicationControllerDummyScale  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedReplicationControllerDummyScale Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)
-- | @application/json@
instance Produces ReadNamespacedReplicationControllerDummyScale MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedReplicationControllerDummyScale MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces ReadNamespacedReplicationControllerDummyScale MimeYaml


-- *** readPodSecurityPolicy

-- | @GET \/apis\/extensions\/v1beta1\/podsecuritypolicies\/{name}@
-- 
-- read the specified PodSecurityPolicy
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readPodSecurityPolicy 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the PodSecurityPolicy
  -> KubernetesRequest ReadPodSecurityPolicy MimeNoContent ExtensionsV1beta1PodSecurityPolicy accept
readPodSecurityPolicy  _ (Name name) =
  _mkRequest "GET" ["/apis/extensions/v1beta1/podsecuritypolicies/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadPodSecurityPolicy  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadPodSecurityPolicy Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "exact" - Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'. Deprecated. Planned for removal in 1.18.
instance HasOptionalParam ReadPodSecurityPolicy Exact where
  applyOptionalParam req (Exact xs) =
    req `setQuery` toQuery ("exact", Just xs)

-- | /Optional Param/ "export" - Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
instance HasOptionalParam ReadPodSecurityPolicy Export where
  applyOptionalParam req (Export xs) =
    req `setQuery` toQuery ("export", Just xs)
-- | @application/json@
instance Produces ReadPodSecurityPolicy MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadPodSecurityPolicy MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces ReadPodSecurityPolicy MimeYaml


-- *** replaceNamespacedDaemonSet

-- | @PUT \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/daemonsets\/{name}@
-- 
-- replace the specified DaemonSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedDaemonSet 
  :: (Consumes ReplaceNamespacedDaemonSet contentType, MimeRender contentType V1beta1DaemonSet)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> V1beta1DaemonSet -- ^ "body"
  -> Name -- ^ "name" -  name of the DaemonSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReplaceNamespacedDaemonSet contentType V1beta1DaemonSet accept
replaceNamespacedDaemonSet _  _ body (Name name) (Namespace namespace) =
  _mkRequest "PUT" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/daemonsets/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedDaemonSet 
instance HasBodyParam ReplaceNamespacedDaemonSet V1beta1DaemonSet 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedDaemonSet Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "dryRun" - When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
instance HasOptionalParam ReplaceNamespacedDaemonSet DryRun where
  applyOptionalParam req (DryRun xs) =
    req `setQuery` toQuery ("dryRun", Just xs)

-- | /Optional Param/ "fieldManager" - fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
instance HasOptionalParam ReplaceNamespacedDaemonSet FieldManager where
  applyOptionalParam req (FieldManager xs) =
    req `setQuery` toQuery ("fieldManager", Just xs)
    
-- | @*/*@
instance MimeType mtype => Consumes ReplaceNamespacedDaemonSet mtype

-- | @application/json@
instance Produces ReplaceNamespacedDaemonSet MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedDaemonSet MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces ReplaceNamespacedDaemonSet MimeYaml


-- *** replaceNamespacedDaemonSetStatus

-- | @PUT \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/daemonsets\/{name}\/status@
-- 
-- replace status of the specified DaemonSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedDaemonSetStatus 
  :: (Consumes ReplaceNamespacedDaemonSetStatus contentType, MimeRender contentType V1beta1DaemonSet)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> V1beta1DaemonSet -- ^ "body"
  -> Name -- ^ "name" -  name of the DaemonSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReplaceNamespacedDaemonSetStatus contentType V1beta1DaemonSet accept
replaceNamespacedDaemonSetStatus _  _ body (Name name) (Namespace namespace) =
  _mkRequest "PUT" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/daemonsets/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedDaemonSetStatus 
instance HasBodyParam ReplaceNamespacedDaemonSetStatus V1beta1DaemonSet 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedDaemonSetStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "dryRun" - When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
instance HasOptionalParam ReplaceNamespacedDaemonSetStatus DryRun where
  applyOptionalParam req (DryRun xs) =
    req `setQuery` toQuery ("dryRun", Just xs)

-- | /Optional Param/ "fieldManager" - fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
instance HasOptionalParam ReplaceNamespacedDaemonSetStatus FieldManager where
  applyOptionalParam req (FieldManager xs) =
    req `setQuery` toQuery ("fieldManager", Just xs)
    
-- | @*/*@
instance MimeType mtype => Consumes ReplaceNamespacedDaemonSetStatus mtype

-- | @application/json@
instance Produces ReplaceNamespacedDaemonSetStatus MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedDaemonSetStatus MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces ReplaceNamespacedDaemonSetStatus MimeYaml


-- *** replaceNamespacedDeployment

-- | @PUT \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/deployments\/{name}@
-- 
-- replace the specified Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedDeployment 
  :: (Consumes ReplaceNamespacedDeployment contentType, MimeRender contentType ExtensionsV1beta1Deployment)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> ExtensionsV1beta1Deployment -- ^ "body"
  -> Name -- ^ "name" -  name of the Deployment
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReplaceNamespacedDeployment contentType ExtensionsV1beta1Deployment accept
replaceNamespacedDeployment _  _ body (Name name) (Namespace namespace) =
  _mkRequest "PUT" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/deployments/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedDeployment 
instance HasBodyParam ReplaceNamespacedDeployment ExtensionsV1beta1Deployment 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedDeployment Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "dryRun" - When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
instance HasOptionalParam ReplaceNamespacedDeployment DryRun where
  applyOptionalParam req (DryRun xs) =
    req `setQuery` toQuery ("dryRun", Just xs)

-- | /Optional Param/ "fieldManager" - fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
instance HasOptionalParam ReplaceNamespacedDeployment FieldManager where
  applyOptionalParam req (FieldManager xs) =
    req `setQuery` toQuery ("fieldManager", Just xs)
    
-- | @*/*@
instance MimeType mtype => Consumes ReplaceNamespacedDeployment mtype

-- | @application/json@
instance Produces ReplaceNamespacedDeployment MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedDeployment MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces ReplaceNamespacedDeployment MimeYaml


-- *** replaceNamespacedDeploymentScale

-- | @PUT \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/deployments\/{name}\/scale@
-- 
-- replace scale of the specified Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedDeploymentScale 
  :: (Consumes ReplaceNamespacedDeploymentScale contentType, MimeRender contentType ExtensionsV1beta1Scale)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> ExtensionsV1beta1Scale -- ^ "body"
  -> Name -- ^ "name" -  name of the Scale
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReplaceNamespacedDeploymentScale contentType ExtensionsV1beta1Scale accept
replaceNamespacedDeploymentScale _  _ body (Name name) (Namespace namespace) =
  _mkRequest "PUT" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/deployments/",toPath name,"/scale"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedDeploymentScale 
instance HasBodyParam ReplaceNamespacedDeploymentScale ExtensionsV1beta1Scale 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedDeploymentScale Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "dryRun" - When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
instance HasOptionalParam ReplaceNamespacedDeploymentScale DryRun where
  applyOptionalParam req (DryRun xs) =
    req `setQuery` toQuery ("dryRun", Just xs)

-- | /Optional Param/ "fieldManager" - fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
instance HasOptionalParam ReplaceNamespacedDeploymentScale FieldManager where
  applyOptionalParam req (FieldManager xs) =
    req `setQuery` toQuery ("fieldManager", Just xs)
    
-- | @*/*@
instance MimeType mtype => Consumes ReplaceNamespacedDeploymentScale mtype

-- | @application/json@
instance Produces ReplaceNamespacedDeploymentScale MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedDeploymentScale MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces ReplaceNamespacedDeploymentScale MimeYaml


-- *** replaceNamespacedDeploymentStatus

-- | @PUT \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/deployments\/{name}\/status@
-- 
-- replace status of the specified Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedDeploymentStatus 
  :: (Consumes ReplaceNamespacedDeploymentStatus contentType, MimeRender contentType ExtensionsV1beta1Deployment)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> ExtensionsV1beta1Deployment -- ^ "body"
  -> Name -- ^ "name" -  name of the Deployment
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReplaceNamespacedDeploymentStatus contentType ExtensionsV1beta1Deployment accept
replaceNamespacedDeploymentStatus _  _ body (Name name) (Namespace namespace) =
  _mkRequest "PUT" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/deployments/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedDeploymentStatus 
instance HasBodyParam ReplaceNamespacedDeploymentStatus ExtensionsV1beta1Deployment 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedDeploymentStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "dryRun" - When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
instance HasOptionalParam ReplaceNamespacedDeploymentStatus DryRun where
  applyOptionalParam req (DryRun xs) =
    req `setQuery` toQuery ("dryRun", Just xs)

-- | /Optional Param/ "fieldManager" - fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
instance HasOptionalParam ReplaceNamespacedDeploymentStatus FieldManager where
  applyOptionalParam req (FieldManager xs) =
    req `setQuery` toQuery ("fieldManager", Just xs)
    
-- | @*/*@
instance MimeType mtype => Consumes ReplaceNamespacedDeploymentStatus mtype

-- | @application/json@
instance Produces ReplaceNamespacedDeploymentStatus MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedDeploymentStatus MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces ReplaceNamespacedDeploymentStatus MimeYaml


-- *** replaceNamespacedIngress

-- | @PUT \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/ingresses\/{name}@
-- 
-- replace the specified Ingress
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedIngress 
  :: (Consumes ReplaceNamespacedIngress contentType, MimeRender contentType ExtensionsV1beta1Ingress)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> ExtensionsV1beta1Ingress -- ^ "body"
  -> Name -- ^ "name" -  name of the Ingress
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReplaceNamespacedIngress contentType ExtensionsV1beta1Ingress accept
replaceNamespacedIngress _  _ body (Name name) (Namespace namespace) =
  _mkRequest "PUT" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/ingresses/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedIngress 
instance HasBodyParam ReplaceNamespacedIngress ExtensionsV1beta1Ingress 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedIngress Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "dryRun" - When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
instance HasOptionalParam ReplaceNamespacedIngress DryRun where
  applyOptionalParam req (DryRun xs) =
    req `setQuery` toQuery ("dryRun", Just xs)

-- | /Optional Param/ "fieldManager" - fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
instance HasOptionalParam ReplaceNamespacedIngress FieldManager where
  applyOptionalParam req (FieldManager xs) =
    req `setQuery` toQuery ("fieldManager", Just xs)
    
-- | @*/*@
instance MimeType mtype => Consumes ReplaceNamespacedIngress mtype

-- | @application/json@
instance Produces ReplaceNamespacedIngress MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedIngress MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces ReplaceNamespacedIngress MimeYaml


-- *** replaceNamespacedIngressStatus

-- | @PUT \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/ingresses\/{name}\/status@
-- 
-- replace status of the specified Ingress
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedIngressStatus 
  :: (Consumes ReplaceNamespacedIngressStatus contentType, MimeRender contentType ExtensionsV1beta1Ingress)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> ExtensionsV1beta1Ingress -- ^ "body"
  -> Name -- ^ "name" -  name of the Ingress
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReplaceNamespacedIngressStatus contentType ExtensionsV1beta1Ingress accept
replaceNamespacedIngressStatus _  _ body (Name name) (Namespace namespace) =
  _mkRequest "PUT" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/ingresses/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedIngressStatus 
instance HasBodyParam ReplaceNamespacedIngressStatus ExtensionsV1beta1Ingress 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedIngressStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "dryRun" - When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
instance HasOptionalParam ReplaceNamespacedIngressStatus DryRun where
  applyOptionalParam req (DryRun xs) =
    req `setQuery` toQuery ("dryRun", Just xs)

-- | /Optional Param/ "fieldManager" - fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
instance HasOptionalParam ReplaceNamespacedIngressStatus FieldManager where
  applyOptionalParam req (FieldManager xs) =
    req `setQuery` toQuery ("fieldManager", Just xs)
    
-- | @*/*@
instance MimeType mtype => Consumes ReplaceNamespacedIngressStatus mtype

-- | @application/json@
instance Produces ReplaceNamespacedIngressStatus MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedIngressStatus MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces ReplaceNamespacedIngressStatus MimeYaml


-- *** replaceNamespacedNetworkPolicy

-- | @PUT \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/networkpolicies\/{name}@
-- 
-- replace the specified NetworkPolicy
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedNetworkPolicy 
  :: (Consumes ReplaceNamespacedNetworkPolicy contentType, MimeRender contentType V1beta1NetworkPolicy)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> V1beta1NetworkPolicy -- ^ "body"
  -> Name -- ^ "name" -  name of the NetworkPolicy
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReplaceNamespacedNetworkPolicy contentType V1beta1NetworkPolicy accept
replaceNamespacedNetworkPolicy _  _ body (Name name) (Namespace namespace) =
  _mkRequest "PUT" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/networkpolicies/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedNetworkPolicy 
instance HasBodyParam ReplaceNamespacedNetworkPolicy V1beta1NetworkPolicy 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedNetworkPolicy Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "dryRun" - When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
instance HasOptionalParam ReplaceNamespacedNetworkPolicy DryRun where
  applyOptionalParam req (DryRun xs) =
    req `setQuery` toQuery ("dryRun", Just xs)

-- | /Optional Param/ "fieldManager" - fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
instance HasOptionalParam ReplaceNamespacedNetworkPolicy FieldManager where
  applyOptionalParam req (FieldManager xs) =
    req `setQuery` toQuery ("fieldManager", Just xs)
    
-- | @*/*@
instance MimeType mtype => Consumes ReplaceNamespacedNetworkPolicy mtype

-- | @application/json@
instance Produces ReplaceNamespacedNetworkPolicy MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedNetworkPolicy MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces ReplaceNamespacedNetworkPolicy MimeYaml


-- *** replaceNamespacedReplicaSet

-- | @PUT \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/replicasets\/{name}@
-- 
-- replace the specified ReplicaSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedReplicaSet 
  :: (Consumes ReplaceNamespacedReplicaSet contentType, MimeRender contentType V1beta1ReplicaSet)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> V1beta1ReplicaSet -- ^ "body"
  -> Name -- ^ "name" -  name of the ReplicaSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReplaceNamespacedReplicaSet contentType V1beta1ReplicaSet accept
replaceNamespacedReplicaSet _  _ body (Name name) (Namespace namespace) =
  _mkRequest "PUT" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/replicasets/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedReplicaSet 
instance HasBodyParam ReplaceNamespacedReplicaSet V1beta1ReplicaSet 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedReplicaSet Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "dryRun" - When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
instance HasOptionalParam ReplaceNamespacedReplicaSet DryRun where
  applyOptionalParam req (DryRun xs) =
    req `setQuery` toQuery ("dryRun", Just xs)

-- | /Optional Param/ "fieldManager" - fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
instance HasOptionalParam ReplaceNamespacedReplicaSet FieldManager where
  applyOptionalParam req (FieldManager xs) =
    req `setQuery` toQuery ("fieldManager", Just xs)
    
-- | @*/*@
instance MimeType mtype => Consumes ReplaceNamespacedReplicaSet mtype

-- | @application/json@
instance Produces ReplaceNamespacedReplicaSet MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedReplicaSet MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces ReplaceNamespacedReplicaSet MimeYaml


-- *** replaceNamespacedReplicaSetScale

-- | @PUT \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/replicasets\/{name}\/scale@
-- 
-- replace scale of the specified ReplicaSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedReplicaSetScale 
  :: (Consumes ReplaceNamespacedReplicaSetScale contentType, MimeRender contentType ExtensionsV1beta1Scale)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> ExtensionsV1beta1Scale -- ^ "body"
  -> Name -- ^ "name" -  name of the Scale
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReplaceNamespacedReplicaSetScale contentType ExtensionsV1beta1Scale accept
replaceNamespacedReplicaSetScale _  _ body (Name name) (Namespace namespace) =
  _mkRequest "PUT" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/replicasets/",toPath name,"/scale"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedReplicaSetScale 
instance HasBodyParam ReplaceNamespacedReplicaSetScale ExtensionsV1beta1Scale 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedReplicaSetScale Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "dryRun" - When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
instance HasOptionalParam ReplaceNamespacedReplicaSetScale DryRun where
  applyOptionalParam req (DryRun xs) =
    req `setQuery` toQuery ("dryRun", Just xs)

-- | /Optional Param/ "fieldManager" - fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
instance HasOptionalParam ReplaceNamespacedReplicaSetScale FieldManager where
  applyOptionalParam req (FieldManager xs) =
    req `setQuery` toQuery ("fieldManager", Just xs)
    
-- | @*/*@
instance MimeType mtype => Consumes ReplaceNamespacedReplicaSetScale mtype

-- | @application/json@
instance Produces ReplaceNamespacedReplicaSetScale MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedReplicaSetScale MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces ReplaceNamespacedReplicaSetScale MimeYaml


-- *** replaceNamespacedReplicaSetStatus

-- | @PUT \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/replicasets\/{name}\/status@
-- 
-- replace status of the specified ReplicaSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedReplicaSetStatus 
  :: (Consumes ReplaceNamespacedReplicaSetStatus contentType, MimeRender contentType V1beta1ReplicaSet)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> V1beta1ReplicaSet -- ^ "body"
  -> Name -- ^ "name" -  name of the ReplicaSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReplaceNamespacedReplicaSetStatus contentType V1beta1ReplicaSet accept
replaceNamespacedReplicaSetStatus _  _ body (Name name) (Namespace namespace) =
  _mkRequest "PUT" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/replicasets/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedReplicaSetStatus 
instance HasBodyParam ReplaceNamespacedReplicaSetStatus V1beta1ReplicaSet 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedReplicaSetStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "dryRun" - When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
instance HasOptionalParam ReplaceNamespacedReplicaSetStatus DryRun where
  applyOptionalParam req (DryRun xs) =
    req `setQuery` toQuery ("dryRun", Just xs)

-- | /Optional Param/ "fieldManager" - fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
instance HasOptionalParam ReplaceNamespacedReplicaSetStatus FieldManager where
  applyOptionalParam req (FieldManager xs) =
    req `setQuery` toQuery ("fieldManager", Just xs)
    
-- | @*/*@
instance MimeType mtype => Consumes ReplaceNamespacedReplicaSetStatus mtype

-- | @application/json@
instance Produces ReplaceNamespacedReplicaSetStatus MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedReplicaSetStatus MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces ReplaceNamespacedReplicaSetStatus MimeYaml


-- *** replaceNamespacedReplicationControllerDummyScale

-- | @PUT \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/replicationcontrollers\/{name}\/scale@
-- 
-- replace scale of the specified ReplicationControllerDummy
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedReplicationControllerDummyScale 
  :: (Consumes ReplaceNamespacedReplicationControllerDummyScale contentType, MimeRender contentType ExtensionsV1beta1Scale)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> ExtensionsV1beta1Scale -- ^ "body"
  -> Name -- ^ "name" -  name of the Scale
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReplaceNamespacedReplicationControllerDummyScale contentType ExtensionsV1beta1Scale accept
replaceNamespacedReplicationControllerDummyScale _  _ body (Name name) (Namespace namespace) =
  _mkRequest "PUT" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/replicationcontrollers/",toPath name,"/scale"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedReplicationControllerDummyScale 
instance HasBodyParam ReplaceNamespacedReplicationControllerDummyScale ExtensionsV1beta1Scale 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedReplicationControllerDummyScale Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "dryRun" - When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
instance HasOptionalParam ReplaceNamespacedReplicationControllerDummyScale DryRun where
  applyOptionalParam req (DryRun xs) =
    req `setQuery` toQuery ("dryRun", Just xs)

-- | /Optional Param/ "fieldManager" - fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
instance HasOptionalParam ReplaceNamespacedReplicationControllerDummyScale FieldManager where
  applyOptionalParam req (FieldManager xs) =
    req `setQuery` toQuery ("fieldManager", Just xs)
    
-- | @*/*@
instance MimeType mtype => Consumes ReplaceNamespacedReplicationControllerDummyScale mtype

-- | @application/json@
instance Produces ReplaceNamespacedReplicationControllerDummyScale MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedReplicationControllerDummyScale MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces ReplaceNamespacedReplicationControllerDummyScale MimeYaml


-- *** replacePodSecurityPolicy

-- | @PUT \/apis\/extensions\/v1beta1\/podsecuritypolicies\/{name}@
-- 
-- replace the specified PodSecurityPolicy
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replacePodSecurityPolicy 
  :: (Consumes ReplacePodSecurityPolicy contentType, MimeRender contentType ExtensionsV1beta1PodSecurityPolicy)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> ExtensionsV1beta1PodSecurityPolicy -- ^ "body"
  -> Name -- ^ "name" -  name of the PodSecurityPolicy
  -> KubernetesRequest ReplacePodSecurityPolicy contentType ExtensionsV1beta1PodSecurityPolicy accept
replacePodSecurityPolicy _  _ body (Name name) =
  _mkRequest "PUT" ["/apis/extensions/v1beta1/podsecuritypolicies/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplacePodSecurityPolicy 
instance HasBodyParam ReplacePodSecurityPolicy ExtensionsV1beta1PodSecurityPolicy 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplacePodSecurityPolicy Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "dryRun" - When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
instance HasOptionalParam ReplacePodSecurityPolicy DryRun where
  applyOptionalParam req (DryRun xs) =
    req `setQuery` toQuery ("dryRun", Just xs)

-- | /Optional Param/ "fieldManager" - fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
instance HasOptionalParam ReplacePodSecurityPolicy FieldManager where
  applyOptionalParam req (FieldManager xs) =
    req `setQuery` toQuery ("fieldManager", Just xs)
    
-- | @*/*@
instance MimeType mtype => Consumes ReplacePodSecurityPolicy mtype

-- | @application/json@
instance Produces ReplacePodSecurityPolicy MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplacePodSecurityPolicy MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces ReplacePodSecurityPolicy MimeYaml

